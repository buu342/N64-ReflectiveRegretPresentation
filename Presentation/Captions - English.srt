1
00:00:01,103 --> 00:00:02,151
[Jeenio]
All right guys, here we go!

2
00:00:02,175 --> 00:00:05,085
I give you Buu342, with the seminar!

3
00:00:11,932 --> 00:00:14,860
[Buu342]
All right, hello everyone and welcome to my little seminar

4
00:00:14,884 --> 00:00:17,405
on Nintendo 64 homebrew game development.

5
00:00:18,241 --> 00:00:22,180
The original intention was to do this 
on the console itself,

6
00:00:22,200 --> 00:00:26,139
but due to issues with the 
hardware that I bought

7
00:00:26,163 --> 00:00:29,859
to get it from RCA (A/V) to HDMI,

8
00:00:29,884 --> 00:00:32,944
it was exactly what I paid... So...

9
00:00:33,194 --> 00:00:35,055
The quality... Fantastic...

10
00:00:35,281 --> 00:00:38,229
So instead we're going to be doing 
this seminar on an emulator

11
00:00:38,254 --> 00:00:40,333
which is not as good...

12
00:00:40,358 --> 00:00:42,867
But, I mean, it's better than 
having no seminar.

13
00:00:42,892 --> 00:00:45,599
Just in case, I have prepared a 
PowerPoint backup

14
00:00:45,624 --> 00:00:48,083
And if my computer decides to
completely die,

15
00:00:48,108 --> 00:00:50,280
then I also have an interpretive dance.

16
00:00:51,366 --> 00:00:55,009
Anyway, let's go into the wonderful, 
wonderful world

17
00:00:55,034 --> 00:00:58,455
of Nintendo 64 homebrew development.

18
00:00:58,693 --> 00:01:00,394
First, a very brief introduction.

19
00:01:01,124 --> 00:01:03,059
My name is Lourenço Soares,

20
00:01:03,084 --> 00:01:06,808
although you might know me more
by the name: Buu342

21
00:01:07,537 --> 00:01:09,038
Pronounce that however you 
want, that can be

22
00:01:09,063 --> 00:01:10,218
B U U three four two,

23
00:01:10,242 --> 00:01:11,969
Buu three hundred forty two...

24
00:01:11,993 --> 00:01:13,887
Whatever is more fun for you!

25
00:01:13,912 --> 00:01:15,193
I'm a computer science student,

26
00:01:15,218 --> 00:01:20,543
I started Nintendo 64 development
more or less around early 2018.

27
00:01:20,568 --> 00:01:24,279
I'm mostly known for a little project
of mine involving a little bird.

28
00:01:25,080 --> 00:01:28,392
Since then, I've been trying to improve
the general development scene

29
00:01:28,880 --> 00:01:31,731
I've made tools, I've written guides...

30
00:01:31,756 --> 00:01:34,582
I've even released a multi-part series

31
00:01:34,607 --> 00:01:37,597
describing the development of
the little bird project.

32
00:01:38,400 --> 00:01:42,189
I've written USB debugging libraries,
texture converters,

33
00:01:42,214 --> 00:01:43,735
and most recently I've released

34
00:01:43,760 --> 00:01:46,662
an animation plug-in and library for
Blender

35
00:01:46,687 --> 00:01:50,531
that allows you to have
fully animated models on the N64

36
00:01:50,556 --> 00:01:51,661
without much trouble.

37
00:01:51,947 --> 00:01:54,277
I do open source everything that I do.

38
00:01:54,302 --> 00:01:55,975
Literally everything!

39
00:01:56,978 --> 00:02:00,600
Thankfully, working on a Nintendo 64 game

40
00:02:00,625 --> 00:02:05,559
It's a lot more accessible now,
and that's generally my idea.

41
00:02:05,805 --> 00:02:11,153
But... The key word there is: "accessible",
not necessarily easier...

42
00:02:11,178 --> 00:02:14,775
Because you see...
the Nintendo 64 was quite difficult.

43
00:02:14,800 --> 00:02:19,915
So much so, that the
hardware development chief at the time,

44
00:02:20,517 --> 00:02:24,964
Genyo Takeda, he referred to the system's
programming challenges by the word

45
00:02:24,989 --> 00:02:28,257
Hansei (反省)
Which means "reflective regret".

46
00:02:28,281 --> 00:02:30,339
(Hence, the name of this presentation)

47
00:02:30,675 --> 00:02:33,440
It's probably not as hard as something like
the PlayStation 2,

48
00:02:33,465 --> 00:02:35,770
which has 10 different processors...

49
00:02:35,795 --> 00:02:40,005
Or the Sega Saturn, which instead of using
triangles it uses quadrilateral meshes,

50
00:02:40,030 --> 00:02:42,476
it has insanely tight timings between
its eight processors

51
00:02:42,501 --> 00:02:43,603
It's a mess...

52
00:02:43,628 --> 00:02:46,776
But, I mean, it's very challenging for
someone who's never done

53
00:02:46,801 --> 00:02:48,916
embedded systems development before.

54
00:02:49,362 --> 00:02:52,942
And it's kind of been getting harder
and easier as time has gone on...

55
00:02:52,967 --> 00:02:55,456
We'll get into that a little bit
better later...

56
00:02:55,818 --> 00:02:58,413
Frankly, honestly, I think there'd be
an alternate universe

57
00:02:58,438 --> 00:03:00,188
where instead of me giving
you this seminar,

58
00:03:00,213 --> 00:03:02,240
I'd instead be giving you this:

59
00:03:03,220 --> 00:03:06,876
But anyway, let's talk about
why this is the case,

60
00:03:06,901 --> 00:03:12,020
the challenges that all developers (and
you, if you're interested in N64

61
00:03:12,045 --> 00:03:13,655
development) will have to face,

62
00:03:13,680 --> 00:03:15,821
the history, and the future...

63
00:03:15,846 --> 00:03:19,402
And obviously, you're going to
be getting this seminar

64
00:03:19,427 --> 00:03:22,282
from someone who not only
drank the Kool-Aid,

65
00:03:22,307 --> 00:03:25,005
but is also actively helping produce it.

66
00:03:25,489 --> 00:03:28,396
So after that little intro,
you're kinda wondering

67
00:03:28,421 --> 00:03:30,879
*why* on earth anyone would want
to do this to themselves?

68
00:03:31,088 --> 00:03:35,621
Well, first of all, the N64 is
kind of in that time where

69
00:03:35,646 --> 00:03:39,204
you can make an entire game by yourself
in a reasonable time frame, and not

70
00:03:39,229 --> 00:03:44,428
have it look too out of place, because
the games aren't super graphically complex.

71
00:03:44,453 --> 00:03:47,201
There's absolutely no assembly 
experience required.

72
00:03:47,226 --> 00:03:51,686
It helps for debugging or
disassembling your code,

73
00:03:51,711 --> 00:03:54,938
but it is not needed at all.

74
00:03:55,612 --> 00:03:58,959
You don't really need any special hardware
or anything,

75
00:03:58,959 --> 00:04:00,443
you just need to get a flashcart.

76
00:04:00,468 --> 00:04:04,202
Or just don't...
But trust me, get a flashcart...

77
00:04:04,227 --> 00:04:08,450
And getting an N64 is like 70$ on eBay,
with a controller.

78
00:04:08,475 --> 00:04:11,120
So, y'know, it's relatively cheap.

79
00:04:11,646 --> 00:04:15,698
And honestly, it feels awesome to get
your code running on the system

80
00:04:15,723 --> 00:04:18,254
I think anyone that's ever done
any sort of homebrew

81
00:04:18,279 --> 00:04:21,289
will agree with that.

82
00:04:21,695 --> 00:04:24,581
So, first let's talk about the hardware

83
00:04:24,606 --> 00:04:28,800
It's a little bit boring, I'm sorry,
but it's kind of a necessary evil...

84
00:04:29,238 --> 00:04:31,292
The hardware was designed by
Silicon Graphics,

85
00:04:31,317 --> 00:04:33,801
which were the leaders of
computer graphics at the time.

86
00:04:33,826 --> 00:04:37,801
It was very ahead of its curve,
retailing at 250$.

87
00:04:38,880 --> 00:04:43,199
Now, I could spend years talking about
ever little minute detail of the N64,

88
00:04:43,199 --> 00:04:45,630
because the community has done
a fantastic job of

89
00:04:45,655 --> 00:04:48,591
reverse engineering protocols,
decapping chips...

90
00:04:48,616 --> 00:04:51,847
But today, I'm going to be focusing
on the three main components

91
00:04:51,872 --> 00:04:54,591
that the programmers only
need to worry about.

92
00:04:54,616 --> 00:04:56,592
and that is: the father,

93
00:04:56,617 --> 00:04:57,828
the son,

94
00:04:57,853 --> 00:04:59,405
and the holy ghost.

95
00:05:00,839 --> 00:05:05,942
So, the CPU, it's a derivative of a
MIPS R4300i,

96
00:05:05,967 --> 00:05:09,328
it has some slightly modified
pin outs and clock rate.

97
00:05:09,353 --> 00:05:14,566
It runs at 93.75 megahertz,
has a 16 kilobyte instruction cache.

98
00:05:14,591 --> 00:05:18,370
It's relatively good at doing
floating point arithmetic.

99
00:05:18,395 --> 00:05:22,695
In fact it's actually faster
than fixed point arithmetic.

100
00:05:23,222 --> 00:05:27,587
It's 64-bit, hence why it was called
the Nintendo 64.

101
00:05:27,612 --> 00:05:32,891
But the system bus is 32 bits wide,
so games are designed with

102
00:05:32,916 --> 00:05:36,021
32-Bit calling conventions
to maximize performance.

103
00:05:36,046 --> 00:05:39,307
So the whole 64 thing is
kind of marketing junk,

104
00:05:39,332 --> 00:05:42,149
but, you know, at the same time
it's also not...

105
00:05:43,026 --> 00:05:45,510
I wanted to get some GoldenEye music
for this, but I didn't have time to

106
00:05:45,535 --> 00:05:46,636
setup audio...

107
00:05:47,406 --> 00:05:52,561
So the RAM is 250 megahertz
Rambus DRAM, or RDRAM for short.

108
00:05:52,829 --> 00:05:56,695
It's 4 megabytes, split into
1 megabyte banks.

109
00:05:56,720 --> 00:06:01,112
But it's actually 4.5 megabytes
because it's actually 9 bit RAM.

110
00:06:01,137 --> 00:06:06,012
The 9th bit is used for anti-aliasing
and Z-buffering by the RCP,

111
00:06:06,037 --> 00:06:09,869
but it's not exposed to the programmer,
so he doesn't need to worry about it.

112
00:06:09,987 --> 00:06:13,646
The data bus is 8 bits
(9 bits, obviously).

113
00:06:13,671 --> 00:06:16,711
It unfortunately has a really high
access latency, but it can

114
00:06:16,736 --> 00:06:21,836
peak at about 562.5 megabytes per second.

115
00:06:21,893 --> 00:06:27,831
It literally stores everything, because the
N64 uses a Unified Memory Architecture,

116
00:06:27,856 --> 00:06:32,919
and it can be expanded to 8MB megabytes
using an expansion pack,

117
00:06:32,944 --> 00:06:36,234
which you can slot into your N64.

118
00:06:36,259 --> 00:06:41,095
The RCP: it's a magical black box
made by Silicon Graphics.

119
00:06:41,120 --> 00:06:44,080
It does pretty much everything
that's related to what will

120
00:06:44,080 --> 00:06:48,071
come out of your TV, so that includes
audio, graphics...

121
00:06:48,096 --> 00:06:50,880
It can also do I/O and
a bunch of other things

122
00:06:50,880 --> 00:06:55,266
It runs parallel to the CPU at
62.5 megahertz,

123
00:06:55,291 --> 00:06:59,109
has absolutely no documentation
whatsoever, because Nintendo was afraid

124
00:06:59,134 --> 00:07:01,872
that competitors would steal
their design,

125
00:07:01,897 --> 00:07:06,008
and it's split into three main parts
parts, which I'll only be focusing on

126
00:07:06,033 --> 00:07:08,899
two of them, which is:
the Reality Display Processor,

127
00:07:08,924 --> 00:07:11,092
and the Reality Signal Processor.

128
00:07:11,117 --> 00:07:13,752
RDP/RSP for short.

129
00:07:14,240 --> 00:07:16,916
The I/O isn't really super important for
the programmer,

130
00:07:16,941 --> 00:07:19,894
so I'm not gonna really focus on it.

131
00:07:20,109 --> 00:07:22,318
The first part, the
Reality Display Processor,

132
00:07:22,343 --> 00:07:25,619
it is a fixed-pipeline
rasterizer + shader.

133
00:07:25,644 --> 00:07:30,168
It can do Z-buffering, mipmapping,
anti-aliasing, pretty much all sorts of

134
00:07:30,193 --> 00:07:34,157
cool high-end stuff, that was
kinda rare at the time.

135
00:07:34,455 --> 00:07:41,849
It has a 4 kilobyte instruction cache,
sorry I mean it has a 4KB texture cache.

136
00:07:41,874 --> 00:07:44,308
Which is really small, we'll get
into that in a bit...

137
00:07:44,679 --> 00:07:48,381
And unfortunately, it needs to be
manually synced,

138
00:07:48,406 --> 00:07:51,540
so anytime that you change
anything on RDP, you need to

139
00:07:51,565 --> 00:07:54,294
manually call a pipeline sync command.

140
00:07:54,319 --> 00:08:00,880
It can reach 640x480, although
typically games ran at 320x240,

141
00:08:00,905 --> 00:08:05,829
because most games were fillrate
limited, not really geometry limited.

142
00:08:06,421 --> 00:08:11,444
So there's people who try to market
CPU overclocking things for the N64,

143
00:08:11,469 --> 00:08:14,560
but that's really stupid because it
won't like help in 90% of the cases.

144
00:08:15,750 --> 00:08:22,687
And the RDP doesn't support shaders,
because it's fixed pipeline,

145
00:08:22,712 --> 00:08:25,085
but it does let you do some
cool stuff with the

146
00:08:25,110 --> 00:08:28,606
Color Combiner and Blender,
which we'll get into in a little bit.

147
00:08:28,807 --> 00:08:32,533
The Reality Signal Processor is a
vector processor.

148
00:08:32,558 --> 00:08:34,804
It can control many different
things in the RDP,

149
00:08:34,829 --> 00:08:39,306
and you can do many other things by
programming it with microcode.

150
00:08:40,148 --> 00:08:46,215
With microcode, you can do graphics,
audio, you can have it decompress assets,

151
00:08:46,251 --> 00:08:49,473
you can even get video running off
of it, if you want.

152
00:08:49,498 --> 00:08:57,669
It is not great for audio, it does 16-bit
audio, but it can do 48 kilohertz stereo.

153
00:08:58,169 --> 00:09:02,726
And it uses fixed point numbers for
best performance. I believe it also has

154
00:09:02,751 --> 00:09:07,496
some floating point operation stuff
there, but frankly just stick to

155
00:09:07,520 --> 00:09:09,146
fixed point numbers...

156
00:09:09,692 --> 00:09:13,636
So, putting all that together, your
hardware looks a little something

157
00:09:13,661 --> 00:09:14,442
like this:

158
00:09:14,660 --> 00:09:17,730
The RCP is at the center and
that's a great thing because

159
00:09:17,755 --> 00:09:19,825
the RCP is the fastest runni-

160
00:09:20,530 --> 00:09:21,725
...

161
00:09:22,399 --> 00:09:24,797
Yeah I really don't know
what they were thinking...

162
00:09:24,822 --> 00:09:28,234
I mean I get *why* it's
at the center

163
00:09:28,259 --> 00:09:31,895
because, you know, RAM stores
everything that you need for drawing,

164
00:09:31,920 --> 00:09:34,667
so the RCP needs to have access
to it all the time.

165
00:09:34,692 --> 00:09:40,175
Giving DMA to it was smart,
but cheaping out on the clock rate

166
00:09:40,200 --> 00:09:44,182
was kind of leaving the rest of the
system at its mercy...

167
00:09:44,214 --> 00:09:48,128
So like, remember that 500 megabyte
per second theoretical RAM peak?

168
00:09:48,399 --> 00:09:48,844
HA!

169
00:09:49,206 --> 00:09:53,176
Yeah, with the RCP running at
60 megahertz, you're gonna be

170
00:09:53,201 --> 00:09:56,614
lucky if you even manage half of that,
especially with half of your

171
00:09:56,639 --> 00:09:59,711
direct memory addressing being
occupied by audio processing.

172
00:10:00,747 --> 00:10:04,144
I mean, I'm being a little bit evil here,
because the N64 was incredibly

173
00:10:04,169 --> 00:10:07,957
tightly designed, after all, the RCP
was made from scratch by

174
00:10:07,982 --> 00:10:10,152
Silicon Graphics for the console.

175
00:10:10,707 --> 00:10:14,345
But obviously, it came at a little bit
of a cost to developers,

176
00:10:14,370 --> 00:10:17,760
Especially because the RCP has
absolutely no documentation.

177
00:10:17,760 --> 00:10:22,621
So you can kind of start to see what
Genyo Takeda was talking about.

178
00:10:23,273 --> 00:10:25,304
So, the N64 uses cartridges.

179
00:10:25,329 --> 00:10:27,814
This was a GREAT idea,
because cartridges are

180
00:10:27,839 --> 00:10:30,935
incredibly fast, you don't really have
any loading screens like you would on

181
00:10:30,960 --> 00:10:35,015
the *stupid* PlayStation 1
(N64 Forever)

182
00:10:35,618 --> 00:10:38,560
And you can even almost stream data
from it.

183
00:10:39,432 --> 00:10:42,058
You can fit in extra hardware
on the cartridges.

184
00:10:42,619 --> 00:10:47,545
Usually cartridges came with 4
Kilobit saves.

185
00:10:47,888 --> 00:10:51,829
You can also have a real-time clock!
One of the games on the N64

186
00:10:51,854 --> 00:10:54,039
has a real-time clock built into
the cartridge.

187
00:10:54,064 --> 00:10:59,212
And there's even a cartridge with
a modem slot in it, so you can plat online.

188
00:11:00,253 --> 00:11:05,294
Now, the cartridges were also a TERRIBLE,
terrible idea, because cartridges are

189
00:11:05,326 --> 00:11:08,880
quite expensive to make especially
compared to pressing some CDs.

190
00:11:10,728 --> 00:11:14,268
Adding in more assets to your game
will balloon the cartridge's cost.

191
00:11:14,293 --> 00:11:17,477
Every little megabyte was really
important at the time.

192
00:11:17,747 --> 00:11:22,492
I only know two games on the Nintendo 64
that are 64 megabytes in size.

193
00:11:22,517 --> 00:11:26,553
Those are: Conker's Bad Fur Day
and Resident Evil 2.

194
00:11:26,578 --> 00:11:30,759
Conker's Bad Fur Day has fully
voice acted cutscenes,

195
00:11:30,784 --> 00:11:33,206
while Resident Evil 2 has full motion
video.

196
00:11:33,231 --> 00:11:34,724
Hence, why they're so big...

197
00:11:34,749 --> 00:11:39,258
Technically, the CPU can address
250 megabytes, and recent discussions

198
00:11:39,283 --> 00:11:43,028
have actually figured out that it can
do almost 2000 megabytes,

199
00:11:43,053 --> 00:11:45,600
but this hasn't properly been
physically tested so

200
00:11:45,600 --> 00:11:47,662
don't take my word on that yet...

201
00:11:47,687 --> 00:11:51,760
But, with a cartridge with
custom hardware on it, you can

202
00:11:51,760 --> 00:11:56,402
implement some sort of like bank switching
thing, and well, there your memory is

203
00:11:56,427 --> 00:11:58,846
pretty much infinite.

204
00:11:59,911 --> 00:12:00,961
[Audience Member]
That's cheating!

205
00:12:00,986 --> 00:12:01,977
[Buu342]
Yeah well,

206
00:12:02,085 --> 00:12:04,222
it's extra hardware so, y'know?

207
00:12:04,448 --> 00:12:08,625
The SNES, they had extra sound chips
on some of their cartridges,

208
00:12:08,650 --> 00:12:12,444
which is pretty cool, and the NES too,
I believe...

209
00:12:12,942 --> 00:12:17,509
So, you're a brand new game dev,
and you want to try developing for

210
00:12:17,534 --> 00:12:21,914
this Ultra 64 thing that Nintendo's
been talking about at E3.

211
00:12:22,152 --> 00:12:27,254
Well, let me give you some pointers as to
why you should become a Nintendo partner.

212
00:12:27,741 --> 00:12:30,704
Not only do you have a direct line of
support with Nintendo,

213
00:12:30,729 --> 00:12:34,801
which also has Q+A's and developer
news, so you can stay updated on

214
00:12:34,826 --> 00:12:37,134
all the Nintendo 64 things.

215
00:12:37,158 --> 00:12:37,970
[Audience Member]
Is it still active?

216
00:12:37,995 --> 00:12:39,948
[Buu342]
No, you wish!

217
00:12:41,043 --> 00:12:44,100
It's compatible with that
Silicon Graphics Indy or Onyx,

218
00:12:44,125 --> 00:12:46,817
if your office happens to have
one of those lying around...

219
00:12:46,842 --> 00:12:50,524
And you get to play around with
all sorts of really fun hardware

220
00:12:50,549 --> 00:12:52,816
which was relatively cheap at the time.

221
00:12:52,841 --> 00:12:54,603
So, lets go over them!

222
00:12:55,524 --> 00:12:59,205
The official Silicon Graphics setup,
as you can see over here.

223
00:12:59,230 --> 00:13:03,450
A Silicon Graphics Indy, which was
the cheaper workstation that could

224
00:13:03,475 --> 00:13:07,839
do N64 stuff, would be priced
around 5000 US Dollars.

225
00:13:08,536 --> 00:13:13,432
Then, you could buy a special
board that you would fit into your Indy.

226
00:13:13,495 --> 00:13:17,920
And, obviously, a tall cartridge with a
debugger port on the top of it.

227
00:13:18,141 --> 00:13:21,296
You'd get a license for something like
MultiGen, which would work on

228
00:13:21,321 --> 00:13:27,760
your Silicon Graphics. And, in total,
you pay about 17,500 dollars

229
00:13:27,785 --> 00:13:30,311
for working on N64 stuff.

230
00:13:30,336 --> 00:13:34,466
Later on, Nintendo did provide some
PC tools, because PCs were

231
00:13:34,491 --> 00:13:39,199
a bit more common and, y'know,
everyone kinda had a PC eventually.

232
00:13:39,929 --> 00:13:43,480
You instead you get a different
emulator and debugger that

233
00:13:43,505 --> 00:13:48,045
Nintendo provides. You will need
some extra hardware for developing

234
00:13:48,070 --> 00:13:51,199
sound stuff, so you'd have to buy the
SoundTools.

235
00:13:51,199 --> 00:13:55,430
And you can get a license for something
like 3DS Max for 4,000 bucks.

236
00:13:55,455 --> 00:14:00,134
A bit cheaper than stuff for
Silicon Graphics machines...

237
00:14:00,839 --> 00:14:08,430
Alternatively, a company called Bung
released something called the Doctor V64,

238
00:14:08,455 --> 00:14:11,335
And you could essentially run
homebrew off of it.

239
00:14:11,360 --> 00:14:14,280
So you could you could get one
of those for about 450 dollars.

240
00:14:14,305 --> 00:14:20,586
You will need a copy of any N64 game so
you can bypass the system's lockout chip.

241
00:14:21,440 --> 00:14:25,360
And since we're trying to be as cheap
as possible, for an animation program

242
00:14:25,360 --> 00:14:30,074
that would work on Windows 95,
I would recommend something like Anim8or.

243
00:14:30,099 --> 00:14:35,273
But, nowadays we don't need to worry
about all this sort of old stuff...

244
00:14:35,298 --> 00:14:40,237
So in a more modern setup, you
would buy a flashcart for about 200 bucks.

245
00:14:40,262 --> 00:14:43,610
You can get a copy of Blender for
literally free, and for audio development

246
00:14:43,635 --> 00:14:46,165
you can use something like
OpenMPT or Anvil Studio

247
00:14:46,190 --> 00:14:48,659
for making MIDI stuff.

248
00:14:49,083 --> 00:14:54,710
So, it's much easier to get into N64
development now, than it was before.

249
00:14:55,806 --> 00:15:00,295
Speaking of SDKs, since you
actually wanna write software,

250
00:15:00,320 --> 00:15:05,694
you're gonna need an SDK, and
there's two main reliable options

251
00:15:05,719 --> 00:15:11,637
for N64. You have "libultra" which
was the official Nintendo 64

252
00:15:11,662 --> 00:15:16,880
development SDK, made by
Nintendo. You get them in disks,

253
00:15:16,880 --> 00:15:18,759
something a little bit like this:

254
00:15:19,970 --> 00:15:24,901
Nowadays you can only really get
them from company liquidation auctions,

255
00:15:24,926 --> 00:15:28,878
or you know you know someone who
happens to have a copy of them.

256
00:15:29,171 --> 00:15:32,646
They'll work on Windows 95 or XP
out of the box, but you can

257
00:15:32,671 --> 00:15:36,792
pretty much get them running on any
modern system using something like

258
00:15:36,817 --> 00:15:43,082
DOSBox, Wine, WSL... We now have something
called the Modern SDK, which you can

259
00:15:43,107 --> 00:15:49,535
pretty much get N64 stuff running
out of the box without any caveats.

260
00:15:49,972 --> 00:15:53,598
Alternatively, you have something like
"libdragon", which is completely

261
00:15:53,622 --> 00:15:54,374
open source.

262
00:15:54,399 --> 00:15:59,264
But, it unfortunately only supports 2d...
This is changing very soon though!

263
00:15:59,289 --> 00:16:02,237
They're making great progress on 3d
microcode.

264
00:16:02,874 --> 00:16:06,000
It will work on pretty much any modern
system, and you can even get it on

265
00:16:06,000 --> 00:16:10,483
something like Docker, if you prefer that.
And it is much, much easier to use

266
00:16:10,546 --> 00:16:13,943
because the libdragon doesn't really
expose much of the operating system

267
00:16:13,977 --> 00:16:15,171
to the developers.

268
00:16:16,496 --> 00:16:20,535
For flashcarts, I know I've already
said this, but

269
00:16:20,560 --> 00:16:20,667
get

270
00:16:20,667 --> 00:16:20,774
get a

271
00:16:20,774 --> 00:16:21,039
get a damn

272
00:16:21,039 --> 00:16:21,966
get a damn flashcart.

273
00:16:22,016 --> 00:16:25,335
Like, really. Yes.
With USB.

274
00:16:25,360 --> 00:16:30,186
Like, I know it costs a little bit, but
it will save you a lot of frustration.

275
00:16:30,211 --> 00:16:32,211
Not all of it, but some of it!

276
00:16:32,640 --> 00:16:35,533
I personally recommend a 64Drive,
it's what I have over here.

277
00:16:35,692 --> 00:16:38,211
It has a USB slot, an SD card slot,

278
00:16:38,236 --> 00:16:39,450
and, a little clicky button!

279
00:16:39,475 --> 00:16:40,043
<Happy clicking noises>

280
00:16:40,068 --> 00:16:40,803
Doesn't do anything!

281
00:16:40,828 --> 00:16:43,033
You can make it programmed
to do stuff though!

282
00:16:44,179 --> 00:16:49,481
The 64Drive was made by someone
called marshallh. He is a great guy,

283
00:16:49,506 --> 00:16:53,987
and he's done *a lot* for the Nintendo 64
community, so I really recommend

284
00:16:54,012 --> 00:16:55,456
getting a 64Drive.

285
00:16:55,481 --> 00:17:00,594
But unfortunately, it's impossible! Because
as of making this presentation,

286
00:17:00,619 --> 00:17:03,346
there have been a lot of
production issues, they're still being

287
00:17:03,371 --> 00:17:08,694
kind of resolved... So you won't be
able to get a 64Drive for a little bit...

288
00:17:08,860 --> 00:17:12,455
The other commercial option is
the EverDrive X7, although

289
00:17:12,480 --> 00:17:15,958
you can get a 3.0 second handed.

290
00:17:16,480 --> 00:17:21,332
It has a slightly slower USB, during
some of my testing, to upload a

291
00:17:21,357 --> 00:17:26,538
64 megabyte ROM, it took almost
an entire minute...

292
00:17:26,959 --> 00:17:30,541
It's not great... But it will work just as
well.

293
00:17:31,120 --> 00:17:34,351
Alternatively, if you prefer to build
a flashcart yourself, you have something

294
00:17:34,376 --> 00:17:37,515
like SummerCart 64, which is completely
open source!

295
00:17:38,507 --> 00:17:41,769
I am going to shill a little bit, but
I've made a multi-platform

296
00:17:41,794 --> 00:17:46,595
tool and library called UNFLoader.
It supports all three of the flashcarts

297
00:17:46,620 --> 00:17:50,048
that I've mentioned in the presentation,
and it also works on both

298
00:17:50,073 --> 00:17:55,262
libultra and libdragon. Use it!
It's probably going to be quite handy.

299
00:17:56,077 --> 00:17:59,879
Especially for projects where you have
many different people with

300
00:17:59,904 --> 00:18:03,564
different hardware. Like this, you
don't need to worry about your

301
00:18:03,589 --> 00:18:06,858
USB code only working for
a specific cartridge.

302
00:18:07,827 --> 00:18:10,471
And one of the main reasons you really
need to get a cartridge is because

303
00:18:10,496 --> 00:18:14,742
you cannot trust Nintendo 64
emulators. Like, at all...

304
00:18:14,767 --> 00:18:19,536
Not even CEN64, which is *the*
cycle accurate emulator.

305
00:18:19,994 --> 00:18:24,478
There's not a single emulator that
emulates properly the Video Interface.

306
00:18:24,760 --> 00:18:28,450
I'm not just talking about like:
"oh this pixel looks slightly off",

307
00:18:28,475 --> 00:18:31,269
No, I'm talking about like more of
its actual quirks.

308
00:18:31,568 --> 00:18:38,167
Developing without a flashcart is almost
impossible because if your game

309
00:18:38,192 --> 00:18:41,654
is running on an emulator, there's no
 guarantee that it will work on

310
00:18:41,679 --> 00:18:43,358
the actual hardware.

311
00:18:43,784 --> 00:18:47,098
So, y'know, if your game only works on
an emulator, you haven't really made a

312
00:18:47,123 --> 00:18:52,559
Nintendo 64 game, you've made a PC game
with extra steps...

313
00:18:52,728 --> 00:18:57,968
For programming, you pretty much develop
almost entirely in C.

314
00:18:58,150 --> 00:19:02,477
You can use a little bit of C++. It was
seldomly use at the time because the

315
00:19:02,502 --> 00:19:03,857
compilers weren't great.

316
00:19:04,381 --> 00:19:05,365
There's one game-

317
00:19:05,446 --> 00:19:07,205
[Audience Member]
Not even today?

318
00:19:07,230 --> 00:19:08,458
[Buu342]
Today you can still use it.

319
00:19:08,483 --> 00:19:09,866
I'll get to that in a second.

320
00:19:11,636 --> 00:19:15,679
There was one commercial game, that I
know of, I'm sure there was a few others,

321
00:19:15,704 --> 00:19:20,559
that use C++ for a few things.
One of them was Kirby64.

322
00:19:20,744 --> 00:19:26,581
Just really, if you want to use C++
nowadays, don't rely on things like STL or-

323
00:19:26,606 --> 00:19:27,220
[Audience Member]
No STL?

324
00:19:27,245 --> 00:19:30,183
[Buu342]
Yeah no STL. A lot of that bloat...

325
00:19:30,208 --> 00:19:30,852
I'm sorry...

326
00:19:30,877 --> 00:19:31,493
[Audience Member]
Bloat?

327
00:19:31,517 --> 00:19:33,970
[Buu342]
No. You can't.

328
00:19:34,804 --> 00:19:39,866
You can develop stuff in assembly,
it's not required nor recommended

329
00:19:39,883 --> 00:19:41,296
for an entire game.

330
00:19:41,321 --> 00:19:45,437
But you can do it if you want to write
some super optimized functions.

331
00:19:45,462 --> 00:19:48,676
Especially because official support
was really poor.

332
00:19:48,724 --> 00:19:52,783
But nowadays you have something like
BASS, armips, and GAS

333
00:19:52,808 --> 00:19:55,178
that you can use your
assemblers of choice.

334
00:19:55,409 --> 00:19:59,966
If you are part of the cults, you
can also use Rust or Zig.

335
00:19:59,991 --> 00:20:04,148
Zig quite recently people have
gotten compilers for those

336
00:20:04,173 --> 00:20:07,520
languages working on the N64.
Just don't expect much

337
00:20:07,545 --> 00:20:12,042
community support or many examples for
that stuff.

338
00:20:13,875 --> 00:20:19,231
For other development tools, I know
this is a bit of a point of contention, but

339
00:20:19,256 --> 00:20:25,614
most of the stuff, you're gonna have
to DIY. The official old tools are

340
00:20:25,639 --> 00:20:30,267
kind of hard to find, or useless
without the special hardware.

341
00:20:31,279 --> 00:20:38,137
For both SDK's, you'll pretty much
write most of your tools, or rely on

342
00:20:38,162 --> 00:20:44,372
community made ones. Luckily, tools have
grown since I originally joined in 2018

343
00:20:44,970 --> 00:20:48,453
(not just thanks to me obviously).
For instance, you want to get

344
00:20:48,478 --> 00:20:53,760
animated models on the N64? Well,
you had to write your own tool and

345
00:20:53,761 --> 00:20:57,631
plugin, or use Super Mario 64's code,
which was recently reverse engineered.

346
00:20:58,210 --> 00:21:02,796
The other option was to grab something
like SoftImage 3D,

347
00:21:03,694 --> 00:21:06,116
and I would not recommend it. It will
tear your hair out-

348
00:21:06,141 --> 00:21:08,516
[Audience Member]
In regards to the reverse engineering

349
00:21:08,541 --> 00:21:11,093
of Super Mario 64. Was that legal?

350
00:21:11,117 --> 00:21:11,752
[Buu342]
Sorry?

351
00:21:11,776 --> 00:21:16,537
[Audience Member]
<Repeats the question>

352
00:21:16,562 --> 00:21:19,883
[Buu342]
I am not a lawyer.

353
00:21:19,908 --> 00:21:22,185
Well, it's still up today, the repository.

354
00:21:22,210 --> 00:21:25,633
The repository's still up, so, y'know?

355
00:21:25,658 --> 00:21:28,320
Nintendo hasn't done anything about it
yet.

356
00:21:29,586 --> 00:21:32,479
Where was I?
Yeah, so, you could grab a copy of

357
00:21:32,504 --> 00:21:35,782
something like SoftImage 3D, and
tear your hair out with the horrible,

358
00:21:35,807 --> 00:21:37,562
horrible controls...

359
00:21:38,925 --> 00:21:44,479
There was a lot of tools for static models,
but nothing really for animated models.

360
00:21:44,740 --> 00:21:50,181
But recently, just this, month we had
three new tools released for Blender

361
00:21:50,206 --> 00:21:53,375
That allows you to have different types
of animated models.

362
00:21:53,400 --> 00:21:55,914
One of them I released, obviously.

363
00:21:56,423 --> 00:22:03,410
For sound, you have things like...
libdragon recently got an XM player

364
00:22:03,435 --> 00:22:07,251
that's microcode assisted, that's
pretty, pretty cool.

365
00:22:07,704 --> 00:22:11,722
libultra also has a bunch of sound
tools, but they're mostly command line

366
00:22:11,747 --> 00:22:15,520
based, so they're not really friendly for
artists who aren't super familiar

367
00:22:15,545 --> 00:22:17,301
with that sort of stuff.

368
00:22:17,841 --> 00:22:20,962
Alternatively, you can use the official
SoundTools...

369
00:22:20,987 --> 00:22:22,159
<shudders>

370
00:22:22,927 --> 00:22:26,588
I mean, they're powerful, but they're
really, really annoying to use without

371
00:22:26,613 --> 00:22:30,474
the official hardware. You have to
jump through a bunch of hoops.

372
00:22:30,662 --> 00:22:35,520
I intend on tackling audio development
a bit later in the future.

373
00:22:36,299 --> 00:22:40,709
If you ever need anything N64
development related, just go to

374
00:22:40,734 --> 00:22:44,473
https://n64.dev
It has all of your resources there,

375
00:22:44,498 --> 00:22:48,818
it's community run, and it's still
updated. But, don't expect to find

376
00:22:48,843 --> 00:22:53,267
something like Unity for N64,
where you can just drag assets

377
00:22:53,292 --> 00:22:57,679
and compile a game. That not
gonna happen.

378
00:22:57,808 --> 00:23:01,775
Ok so, we got the boring stuff,
out of the way, let's actually

379
00:23:01,800 --> 00:23:04,621
talk about making games for the
Nintendo64.

380
00:23:04,843 --> 00:23:09,436
I mostly use libultra, but I have
consulted a little bit with the

381
00:23:09,461 --> 00:23:13,496
libdragon developers, so this section
should be relevant to both people.

382
00:23:13,703 --> 00:23:18,620
The Nintendo 64 provides a very small
kernel. Everything is pretty much

383
00:23:18,645 --> 00:23:22,821
done by you, tailored specifically
for your game. libdragon handles

384
00:23:22,846 --> 00:23:31,496
a lot of the OS overhead. Heck, if you,
work with libdragon, you don't even

385
00:23:31,521 --> 00:23:33,600
need to worry about what a thread is.

386
00:23:34,110 --> 00:23:38,640
With libultra, you need to write
the OS yourself. You can alternatively

387
00:23:38,640 --> 00:23:42,741
use Nintendo's Nusys, which was
something that they provided

388
00:23:42,766 --> 00:23:47,731
later on which helps get rid of a lot of
the boilerplate when you're starting

389
00:23:47,756 --> 00:23:48,908
your project.

390
00:23:48,933 --> 00:23:52,816
Regardless of what route you decide to
take, there's no harm in understanding

391
00:23:52,841 --> 00:23:56,293
the driving forces behind what actually
makes the machine tick.

392
00:23:56,823 --> 00:24:04,016
So, the N64's CPU is a single core CPU,
threading is handled entirely by you.

393
00:24:04,393 --> 00:24:10,069
libultra exposes a preemptive
scheduler, where threads are given

394
00:24:10,094 --> 00:24:16,226
priorities. They only yield to the next
highest priority when choose to do so.

395
00:24:16,462 --> 00:24:20,987
However, a thread can be interrupted
by the hardware and it can be switched

396
00:24:21,012 --> 00:24:23,290
to another thread.

397
00:24:23,928 --> 00:24:28,510
Essentially, the way that it works is:
the CPU gives the RCP things to do,

398
00:24:28,535 --> 00:24:32,799
like for instance, render a frame,
and the RCP does that on its own.

399
00:24:32,824 --> 00:24:35,689
The CPU then continues doing
whatever it wants.

400
00:24:35,722 --> 00:24:39,905
Then, when the RCP finishes, it will
generate an interrupt, and the CPU will

401
00:24:39,930 --> 00:24:44,064
then process whatever happened, and give
the RCP another task.

402
00:24:44,089 --> 00:24:46,879
It's essentially just a back and forth
like that.

403
00:24:46,904 --> 00:24:49,760
Threads can communicate between
each other's using messages.

404
00:24:49,761 --> 00:24:52,653
you'd probably want to have a message
queue so that you can deal with

405
00:24:52,678 --> 00:24:55,520
stuff later if it's not super important.

406
00:24:55,720 --> 00:25:01,071
Threads can be paused at any time to,
for instance, want this thread to only

407
00:25:01,096 --> 00:25:05,403
run as soon as it receives a message
or a specific interrupt/event, like if

408
00:25:05,428 --> 00:25:09,895
your game crashes. You can have a
thread only run when that happens.

409
00:25:10,553 --> 00:25:15,307
There are no threads in libdragon,
because libdragon uses an asynchronous

410
00:25:15,332 --> 00:25:19,405
programming paradigm, but you can
choose to write an interrupt handler for

411
00:25:19,430 --> 00:25:22,682
when, like, tasks finish, so that you can
schedule more.

412
00:25:23,182 --> 00:25:28,039
Though libdragon is intending to
change this with a recent PR for a

413
00:25:28,064 --> 00:25:31,730
kernel rewrite, so you can look
forward to that.

414
00:25:32,183 --> 00:25:35,920
So, speaking of microcode since I've
mentioned microcode a little bit.

415
00:25:35,945 --> 00:25:42,221
When you're making RSP tasks
from the CPU, you can choose what

416
00:25:42,246 --> 00:25:47,464
microcode to execute. microcode is
usually linked in the ROM itself as

417
00:25:47,489 --> 00:25:48,777
a binary blob.

418
00:25:49,545 --> 00:25:53,679
There's a few options for microcode I'll
go over some of them quite briefly.

419
00:25:53,704 --> 00:25:59,694
You have F3DEX, which is the 3D
microcode of choice.

420
00:25:59,719 --> 00:26:05,526
Originally the microcode was called Fast3D,
and it was written by Silicon Graphics.

421
00:26:05,551 --> 00:26:11,575
Although, it was not very good because
Silicon Graphics designed it to render

422
00:26:11,600 --> 00:26:15,611
high quality triangles, which is not a
great idea for games....

423
00:26:15,939 --> 00:26:18,226
Where y'know, you need to
run things fast...

424
00:26:19,006 --> 00:26:24,749
Eventually, Nintendo wrote the
F3DEX series and they replaced the

425
00:26:24,774 --> 00:26:26,237
Fast3D microcode.

426
00:26:26,388 --> 00:26:30,252
For open source stuff, you have
something called ugfx, which came

427
00:26:30,277 --> 00:26:32,784
out quite recently. It came out last
month!

428
00:26:32,943 --> 00:26:39,158
But, it is currently having a complete
API rewrite. So if you choose to use it

429
00:26:39,183 --> 00:26:42,683
now, you do need to be aware that
in the future, everything will be broken.

430
00:26:43,033 --> 00:26:49,476
There's also an unfinished, but very
promising looking, 3D microcode: libhfx.

431
00:26:49,819 --> 00:26:56,774
For 2D stuff, you have S2DEX, but
you can also just use F3DEX

432
00:26:56,799 --> 00:27:02,741
microcode for your 2D rendering stuff.

433
00:27:03,168 --> 00:27:05,320
So, like that, you don't need to be
swapping out

434
00:27:05,321 --> 00:27:08,371
microcode between tasks, you can just
use F3DEX for that.

435
00:27:08,787 --> 00:27:15,682
libdragon doesn't have any 2D
microcode, because it generates the

436
00:27:15,707 --> 00:27:23,092
commands on the CPU and issues them
directly to the RDP.

437
00:27:24,357 --> 00:27:28,269
Audio. For audio, you have something
like naudio, which is the Nintendo

438
00:27:28,294 --> 00:27:34,677
audio microcode. And libdragon now
recently got something called the

439
00:27:34,702 --> 00:27:35,836
RSP mixer.

440
00:27:36,080 --> 00:27:39,296
I'll cover a little bit of audio
a little bit later.

441
00:27:39,577 --> 00:27:43,967
If you're so inclined, you also have
microcode for video decoding.

442
00:27:44,301 --> 00:27:49,982
Nintendo provided something called
HVQM, but we recently got something

443
00:27:50,007 --> 00:27:58,957
which allows you to use H264, which is
very, very good and runs very very well.

444
00:28:00,012 --> 00:28:07,373
There were some developers like Rare and
Factor 5, that Nintendo gave them the

445
00:28:07,398 --> 00:28:12,640
source code for microcode and the very,
very bad documentation that the

446
00:28:12,641 --> 00:28:14,713
source code had.

447
00:28:14,761 --> 00:28:20,478
And these two companies went through
hell to write really good microcode to make

448
00:28:20,519 --> 00:28:24,625
their games look fantastic. I mean, Conker
 almost looks like something that would

449
00:28:24,650 --> 00:28:28,410
run on the GameCube, it's very impressive
how much work they put into that.

450
00:28:28,435 --> 00:28:31,252
[Audience Member]
Has someone ported Bad Apple to it?

451
00:28:31,847 --> 00:28:37,745
[Buu342]
Yes! Someone has ported Bad Apple to it...

452
00:28:37,770 --> 00:28:39,340
Obviously!

453
00:28:40,098 --> 00:28:45,056
I have absolutely no experience writing
microcode, but it is easier to write

454
00:28:45,081 --> 00:28:49,053
microcode nowadays, because there's
been a lot of hard work into getting

455
00:28:49,078 --> 00:28:53,231
an interactive RSP disassembler
called r64emu.

456
00:28:53,256 --> 00:28:58,132
Like, the developers at the time WISH
they had something as good as that.

457
00:28:59,127 --> 00:29:03,265
So, remember how I mentioned that
memory that the N64 uses a sort of

458
00:29:03,290 --> 00:29:05,688
unified memory architecture?

459
00:29:05,713 --> 00:29:11,008
Well, you see, the RCP has really, really
small registers. Like, it only has a

460
00:29:11,033 --> 00:29:16,455
four kilobyte instruction cache. It's
very very tiny... So if you have large

461
00:29:16,479 --> 00:29:19,689
microcode, you need to load it in
as parts.

462
00:29:20,119 --> 00:29:26,324
So pretty much everything will be
stored in RAM, 4 megabytes sounds

463
00:29:26,349 --> 00:29:31,137
like it's a lot, but that space is being
contested by everything, like your

464
00:29:31,162 --> 00:29:35,837
framebuffer and Z-buffer, and obviously
the framebuffer and Z-Buffer's sizes

465
00:29:35,862 --> 00:29:45,214
will depend on your region. Typically on
NTSC systems, the buffers were 320x240

466
00:29:45,752 --> 00:29:48,619
(320x288 if you're on PAL).

467
00:29:49,996 --> 00:29:53,826
It does support some other weirder
resolutions if you really have to.

468
00:29:53,851 --> 00:29:58,402
Typically you'd have two framebuffers,
so you can do double buffering for a

469
00:29:58,427 --> 00:30:02,748
small framerate boost. So if you do
the math, that's about 300 kilobytes

470
00:30:02,773 --> 00:30:08,506
for two framebuffers. It's double that
if you're using a 32-Bit color depth,

471
00:30:08,531 --> 00:30:13,635
on top of the 150 that's being used by
the Z-buffer, so that's half a meg

472
00:30:13,660 --> 00:30:14,097
<Snap>

473
00:30:14,122 --> 00:30:15,304
gone, like that.

474
00:30:16,552 --> 00:30:22,488
Although you, can cheat for PAL, because
the video interface lets you stretch the

475
00:30:22,513 --> 00:30:28,899
Y scale for each horizontal scanline, while
still using an NTSC sized framebuffer.

476
00:30:28,924 --> 00:30:33,596
But, it will make your stuff look
a little blurry on PAL and will make

477
00:30:33,621 --> 00:30:35,517
me cry a lot.

478
00:30:35,542 --> 00:30:42,705
RAM is made of 1 megabyte banks,
so putting both frame buffers in different

479
00:30:42,730 --> 00:30:46,956
banks will improve the performance.
Because each time that you

480
00:30:46,981 --> 00:30:51,931
write or read to a bank, you have to wait
for the operation to finish before the

481
00:30:51,956 --> 00:30:54,708
same bank can be accessed again.

482
00:30:56,056 --> 00:31:01,808
The RAM interface supports multiple
banks at once, that allows you to read

483
00:31:01,833 --> 00:31:05,314
from different banks while one is
being used.

484
00:31:05,339 --> 00:31:09,763
Remember, you have full control of the
memory layout, so alternate your data

485
00:31:09,788 --> 00:31:12,204
between the banks, it helps a lot.

486
00:31:12,566 --> 00:31:18,398
I was going to give an example of this
in practice, but because we are on an

487
00:31:18,423 --> 00:31:20,528
emulator it, won't really matter.

488
00:31:20,894 --> 00:31:26,198
The idea here is that this first scene
is being rendered with the framebuffers

489
00:31:26,223 --> 00:31:31,129
in separate banks, and then the second
scene is then being rendered with the

490
00:31:31,154 --> 00:31:34,772
frambuffers all in the same bank. And
you would see that this one would

491
00:31:34,797 --> 00:31:37,002
run a little bit worse.

492
00:31:37,355 --> 00:31:41,536
The time up there is in milliseconds.

493
00:31:41,561 --> 00:31:43,403
[Audience Member]
That's in milliseconds?

494
00:31:43,428 --> 00:31:46,967
[Buu342]
Uh yeah, roughly.

495
00:31:48,479 --> 00:31:52,757
So speaking of memory management, the
bootcode will copy the very first

496
00:31:52,782 --> 00:31:56,410
megabyte from ROM, and it will
execute it.

497
00:31:56,767 --> 00:32:00,292
There is absolutely no way to change
this without modifying the bootcode itself,

498
00:32:00,317 --> 00:32:04,927
which is not trivial for a bunch of reasons
that I'm not going to get into here.

499
00:32:05,241 --> 00:32:09,461
Essentially, this means, don't put
your data in your code segment or

500
00:32:09,486 --> 00:32:12,009
you'll very quickly surpass this limit.

501
00:32:12,034 --> 00:32:18,014
The cartridge is very fast, so you can load
assets from it as your game is running.

502
00:32:18,160 --> 00:32:23,139
If you DO happen to hit that one
megabyte limit, you can apply some

503
00:32:23,164 --> 00:32:25,930
classic operating system techniques to
work around it.

504
00:32:25,955 --> 00:32:31,624
So, overlays, which is, you essentially
say "this" block of code occupies

505
00:32:31,649 --> 00:32:35,262
"this" position in memory, and
"this other" block of code ALSO

506
00:32:35,287 --> 00:32:39,196
occupies the exact same place in
memory, but only one block of code

507
00:32:39,221 --> 00:32:43,487
will ever be active at a time, so
you can swap them out.

508
00:32:43,765 --> 00:32:48,380
Alternatively, you can use something like
relocatable modules, where it's the

509
00:32:48,405 --> 00:32:51,354
exact same thing, where you have
a block of code,

510
00:32:51,379 --> 00:32:53,957
you get it from memory, and you
just place it somewhere.

511
00:32:53,982 --> 00:33:00,136
But the thing about relocatable modules
is that the pointers are corrected for

512
00:33:00,161 --> 00:33:07,463
wherever you put it in RAM, so you're not
forced to overlay it with the other code.

513
00:33:07,488 --> 00:33:12,194
So you can have multiple different
things running at once.

514
00:33:13,232 --> 00:33:19,137
Since we're talking about getting stuff
from ROM, you're essentially talking about

515
00:33:19,162 --> 00:33:25,070
a filesystem. The N64 doesn't force any
structure for your filesystem, so just

516
00:33:25,095 --> 00:33:29,737
do whatever you want with memory.
libdragon has its own filesystem that

517
00:33:29,762 --> 00:33:32,364
you might find quite handy.

518
00:33:33,033 --> 00:33:37,686
Speaking of memory management,
it's important to mention that the CPU

519
00:33:37,711 --> 00:33:42,088
runs in kernel mode, so there's a bit
of legwork that you need to do.

520
00:33:42,356 --> 00:33:49,066
The CPU usually runs in KSEG0's address
space, it's direct memory mapped, cached.

521
00:33:49,203 --> 00:33:54,907
While the RCP expects the addresses that
you give it to be physical addresses.

522
00:33:54,932 --> 00:33:57,571
So you do need to manually correct that.

523
00:33:58,239 --> 00:34:03,557
Because the CPU transparently caches
data accesses on the onboard data cache,

524
00:34:03,582 --> 00:34:10,804
when you DMA stuff, to y'know, get assets
from ROM, the data is held in the cache

525
00:34:10,829 --> 00:34:16,572
until the cache line is written back,
usually because a cache miss occurs

526
00:34:16,597 --> 00:34:21,569
which requires the same cache line.
Because they will no longer agree

527
00:34:21,594 --> 00:34:26,016
on the contents of the cache, you'll
need to manually writeback the

528
00:34:26,041 --> 00:34:31,598
data cache or invalidate it when you have
more recent data in your physical memory.

529
00:34:31,623 --> 00:34:35,947
Y'know, it's some extra annoying steps
that the developers had to worry about

530
00:34:35,972 --> 00:34:37,131
at the time.

531
00:34:37,984 --> 00:34:42,052
Okay so, let's talk a little bit about
graphics. This section is when it's

532
00:34:42,077 --> 00:34:44,544
it's going to get a little dense, so give
me a sec.

533
00:34:48,170 --> 00:34:52,461
Okay so, first and foremost, this
question gets asked a lot but

534
00:34:52,486 --> 00:34:56,283
no, the Nintendo 64 does NOT use
OpenGL.

535
00:34:56,654 --> 00:35:00,868
Yes, the OpenGL API was written by
Silicon Graphics,

536
00:35:00,917 --> 00:35:07,415
and at the time, their machines were
working with their proprietary IRIS GL,

537
00:35:07,440 --> 00:35:13,222
but the N64 uses its own thing. We
sometimes call it N64GL

538
00:35:13,247 --> 00:35:14,397
Not an official name!

539
00:35:15,448 --> 00:35:22,085
That's not saying that knowing stuff about
OpenGL is useless, it is not, it will help

540
00:35:22,110 --> 00:35:28,144
you, especially the main concepts like
matrix calculations, lighting,

541
00:35:28,164 --> 00:35:32,023
but you know there's a lot of
small differences in the details.

542
00:35:32,481 --> 00:35:39,019
Regardless, if you do happen to have a copy
of the "OpenGL Superbible: First Edition",

543
00:35:40,708 --> 00:35:44,856
This is a great book, you want to get
resources essentially for the 1.0

544
00:35:44,881 --> 00:35:48,903
iterations of OpenGL, the ones that use
display lists.

545
00:35:48,991 --> 00:35:51,760
It's going to be quite a useful resource
for you.

546
00:35:52,824 --> 00:36:00,216
So, I just mentioned the N64 uses
display lists, because the graphics cards

547
00:36:00,241 --> 00:36:03,910
at the time were mostly fixed
function pipelines.

548
00:36:04,177 --> 00:36:07,953
you can dynamically create display lists
as your application is running, or you

549
00:36:07,978 --> 00:36:13,181
have some static pre-made display
lists for static data, like your

550
00:36:13,206 --> 00:36:16,519
character models, the vertices aren't
really going to change, so you

551
00:36:16,544 --> 00:36:18,549
don't need to generate those dynamically.

552
00:36:18,574 --> 00:36:23,050
In OpenGL, you have something called the
post transform cache, which is a small

553
00:36:23,075 --> 00:36:28,716
memory buffer where you put in
vertices when they're being processed,

554
00:36:28,741 --> 00:36:30,340
but not yet rendered.

555
00:36:30,365 --> 00:36:35,675
The N64 has an explicitly managed
version of this, with the size of the

556
00:36:35,700 --> 00:36:38,572
cache itself depending on which
microcode you're using.

557
00:36:38,770 --> 00:36:43,536
The tricky part about this is that
the vertices you load need to be

558
00:36:43,561 --> 00:36:47,715
in contiguous order. So, for instance,
if you have a vertex cache size of

559
00:36:47,740 --> 00:36:54,777
32, you can't selectively load vertex
number 4 and then load vertex 64.

560
00:36:54,802 --> 00:36:59,825
You can't do that, you have to order your
vertices so that you know they fit in

561
00:36:59,850 --> 00:37:01,333
blocks together.

562
00:37:03,622 --> 00:37:07,218
Or, if you can't do that, then you
need to duplicate your vertices.

563
00:37:07,397 --> 00:37:11,662
there's quite a few algorithms for this,
like Tipsify, or Forsyth, but it's

564
00:37:11,687 --> 00:37:13,816
relatively easy to write your own.

565
00:37:13,841 --> 00:37:18,101
Preventing cache misses when you're
loading your vertices is relatively easy,

566
00:37:18,126 --> 00:37:21,465
and it's a great way to improve your
performance, even though you don't

567
00:37:21,490 --> 00:37:27,106
need to spend years trying to improve
the algorithm, because it's going

568
00:37:27,131 --> 00:37:30,879
to a point where you're going to be
fillrate limited so... It won't really

569
00:37:30,904 --> 00:37:32,108
matter too much.

570
00:37:32,345 --> 00:37:39,367
The N64's graphics API provides a 10
element modeling matrix stack, like you'd

571
00:37:39,392 --> 00:37:45,189
kinda expect any modern graphics API
to have, the catch is that the matrix

572
00:37:45,214 --> 00:37:51,660
stacking is done when the RSP is processing
the display list tasks themselves, so

573
00:37:51,685 --> 00:37:57,736
you can't just call a matrix push operation
and then reuse that matrix for

574
00:37:57,761 --> 00:38:04,255
something else with the CPU. You have to
keep that matrix loaded in memory otherwise

575
00:38:04,280 --> 00:38:08,316
you're you're gonna run into
some problems...

576
00:38:09,192 --> 00:38:14,219
It also supports vertex colors, which
are used to great extent in a lot of

577
00:38:14,244 --> 00:38:18,193
titles, however be aware that you
can't actually mix vertex colors

578
00:38:18,218 --> 00:38:22,640
and lighting, because the lighting is
actually faked. It's modifying the

579
00:38:22,665 --> 00:38:24,896
vertex colors directly.

580
00:38:25,695 --> 00:38:30,232
You can, however, mix primitive colors
with lighting, you just can't mix the

581
00:38:30,257 --> 00:38:33,208
individual vertex colors.

582
00:38:33,580 --> 00:38:38,582
The largest point of contention for most
people with the system is that the

583
00:38:38,607 --> 00:38:43,266
texture memory is tiny, it's
4 kilobytes...

584
00:38:43,488 --> 00:38:47,315
For reference, if you have an 32-Bit color
image,

585
00:38:47,710 --> 00:38:52,185
this is the size of the texture
that you can fit in that memory.

586
00:38:52,432 --> 00:38:55,249
[Audience Member]
Just one question, why did they end up

587
00:38:55,274 --> 00:38:57,627
making the texture memory so small?

588
00:38:57,991 --> 00:39:00,614
[Buu342]
Probably cost saving measures, you'd

589
00:39:00,639 --> 00:39:03,015
have to ask a Silicon Graphics engineer.

590
00:39:04,321 --> 00:39:06,885
This joke would have been funnier on
the console because this would have

591
00:39:06,910 --> 00:39:08,427
looked a little bit smaller.

592
00:39:09,401 --> 00:39:14,076
For reference, this is a 32x32 pixel
image.

593
00:39:14,984 --> 00:39:19,055
If you're using mipmapping, that's
going to get even smaller, that's

594
00:39:19,080 --> 00:39:20,766
gonna be half of that...

595
00:39:21,248 --> 00:39:25,381
There is no way to bypass this
limitation, because it needs the

596
00:39:25,406 --> 00:39:29,992
textures to be loaded into texture
memory for the RDP to use them.

597
00:39:30,192 --> 00:39:34,446
The best thing that you can do to
render high quality textures is to

598
00:39:34,471 --> 00:39:38,886
either reduce the bit depth of the
texture itself, like for instance this

599
00:39:38,911 --> 00:39:45,115
texture doesn't use any alpha so I can
forego the alpha bits completely,

600
00:39:46,129 --> 00:39:51,799
or you can instead use something like
4-Bit black and white textures,

601
00:39:51,824 --> 00:39:57,147
and then just use vertex colors to
color your texture. Like that, you

602
00:39:57,172 --> 00:40:00,999
can almost fit a 128x128 texture in it.

603
00:40:02,376 --> 00:40:07,706
Or the other choice is to chunk your
images and load them bit by bit.

604
00:40:07,951 --> 00:40:12,011
If you're doing this for a model, you'll
need to increase the number of triangles

605
00:40:12,036 --> 00:40:13,703
on the model itself.

606
00:40:14,544 --> 00:40:18,538
So I mentioned the Color Combiner. This
is the closest thing that you're going

607
00:40:18,563 --> 00:40:20,670
to have to a fragment shader.

608
00:40:22,028 --> 00:40:26,680
The Color Combiner is essentially a
very, very simple equation.

609
00:40:26,705 --> 00:40:32,116
It's:
(a - b)*c + d

610
00:40:32,994 --> 00:40:37,930
These variables, you can essentially
fit from a few different sources.

611
00:40:37,955 --> 00:40:43,866
So you can fit in the texture color, the
vertex color, you can fit in noise,

612
00:40:43,891 --> 00:40:49,759
primitive color, the ambient color, or
just a 1 or a 0.

613
00:40:50,196 --> 00:40:54,570
The color combiner is also used for
alpha, and it uses the exact same equation.

614
00:40:55,044 --> 00:40:58,747
the cool thing about the color combiner is
that you can do it in two different passes.

615
00:40:58,772 --> 00:41:06,057
So, you can calculate a specific color
in one pass, and then use the

616
00:41:06,082 --> 00:41:11,563
value that you calculated as a variable
in your second pass.

617
00:41:11,816 --> 00:41:16,633
This will obviously be slower, since each
pixel now needs to be processed twice

618
00:41:16,658 --> 00:41:18,060
with the Color Combiner.

619
00:41:19,026 --> 00:41:23,341
And this will even allow you to do three
color multiplications, because this formula

620
00:41:23,366 --> 00:41:26,909
only lets you do two color multiplications
if you do it in a single pass.

621
00:41:27,028 --> 00:41:30,187
Let me demonstrate.
So over here I have everything

622
00:41:30,212 --> 00:41:34,389
set to 0, so we just have a black
square.

623
00:41:35,398 --> 00:41:41,014
Or, I can change "d" to-
Sorry, I didn't mean to hit that button...

624
00:41:42,129 --> 00:41:47,393
I can change "d" to instead be a 1, and
now it's pure white, which is probably

625
00:41:47,418 --> 00:41:49,576
going to be very, very difficult to see.

626
00:41:50,092 --> 00:41:54,471
We can replace "d" instead to use the
vertex color, or we can have it with

627
00:41:54,496 --> 00:41:56,013
the texture color.

628
00:41:57,582 --> 00:42:03,175
You can replace "a" with the vertex
color, and "c" with the texture color,

629
00:42:03,200 --> 00:42:07,391
and you can multiply them.
It's a little bit hard to see over here

630
00:42:07,416 --> 00:42:11,401
on the projector, sorry about that
guys. Should be fine on the stream...

631
00:42:11,426 --> 00:42:12,053
I hope...

632
00:42:13,552 --> 00:42:19,350
You can also change "a" to be noise.
Noise only seems to work on "a", I

633
00:42:19,375 --> 00:42:22,551
can't really get it to work on the
other variables, I'm not sure why...

634
00:42:23,333 --> 00:42:29,273
And then replace "c" with the vertex
color, and "d" with the texel color-

635
00:42:29,298 --> 00:42:31,782
Whoops, I keep pressing the wrong button...

636
00:42:31,972 --> 00:42:36,922
And you're gonna get something that looks
a little bit like this. And obviously, if

637
00:42:36,947 --> 00:42:40,530
you wanna do something a little bit
more fancy, you can mix in ambient

638
00:42:40,555 --> 00:42:46,705
color by doing it in a second pass. So
I've replaced "a" with the combined result

639
00:42:46,730 --> 00:42:51,880
of the first pass and then multiplied
all of that by the ambient color.

640
00:42:52,754 --> 00:42:54,969
Okay, now we can actually go to this
slide...

641
00:42:54,994 --> 00:43:02,877
The Blender, it essentially combines the
calculated value from the Color Combiner,

642
00:43:02,902 --> 00:43:06,102
and it blends it with the ones in the
framebuffer. It also does the

643
00:43:06,127 --> 00:43:08,960
anti-aliasing and Z-buffering.

644
00:43:09,190 --> 00:43:12,039
It's essentially what shades the final
pixel.

645
00:43:12,064 --> 00:43:17,899
I didn't demonstrate this in the
previous slide, but the Color Combiner

646
00:43:17,924 --> 00:43:22,183
and the Blender kind of need to work
together for the output to be correct.

647
00:43:22,351 --> 00:43:27,366
The Blender is a pretty complex beast,
it has more than one equation for

648
00:43:27,391 --> 00:43:32,098
calculating which pixel gets outputted.
Like, there's a specific formula

649
00:43:32,123 --> 00:43:34,866
if you want to use fog.

650
00:43:35,751 --> 00:43:42,209
The N64 manual has this really big
matrix that shows all the different

651
00:43:42,234 --> 00:43:45,713
sources that you can use for the
Blender and what they will do.

652
00:43:45,916 --> 00:43:50,415
I'm not really gonna get into the
Blender because I don't wanna

653
00:43:50,440 --> 00:43:55,475
take too much time, I only have an hour, so
we're not gonna really talk about it much.

654
00:43:55,500 --> 00:43:59,944
Just read the manual, it'll cover it
a lot better than I could.

655
00:44:00,588 --> 00:44:05,464
Okay so, model animations. It helps to
have your models animated to make your

656
00:44:05,489 --> 00:44:07,654
game look a little bit more interesting.

657
00:44:07,679 --> 00:44:11,591
But the fact that the Nintendo 64
doesn't really provide any ways to

658
00:44:11,616 --> 00:44:16,438
easily do this, any built-in ways, it's a
bit overwhelming for newcomers who've

659
00:44:16,463 --> 00:44:19,560
never had to implement something
like a skinning system before.

660
00:44:20,134 --> 00:44:25,426
The most common used system by the
the games on the N64 was something that

661
00:44:25,451 --> 00:44:30,286
we call the "sausage link" system, although
I'm not sure if there's an official name

662
00:44:30,311 --> 00:44:35,430
for this? But I doubt it sounds as cool as
"sausage links". Essentially, remember

663
00:44:35,455 --> 00:44:38,798
that little animated model I made
for the intro?

664
00:44:38,823 --> 00:44:44,347
It's made of a bunch of separate
segments, and they're really easy to

665
00:44:44,372 --> 00:44:51,112
manipulate individually by a matrix.
And it's relatively lightweight in

666
00:44:51,137 --> 00:44:54,382
terms of memory, because you only
need to store the final position,

667
00:44:54,407 --> 00:44:57,935
rotation, and scale values for each
keyframe of the animation.

668
00:44:58,798 --> 00:45:03,489
And you can use the CPU to lerp
between the different frames.

669
00:45:05,521 --> 00:45:11,427
The RSP is the one that's doing all the
vertex transformations, so your CPU

670
00:45:11,452 --> 00:45:13,472
is free to do other things.

671
00:45:13,672 --> 00:45:18,504
You can also have fully skinned models
like you would have on a modern game.

672
00:45:19,008 --> 00:45:23,914
One of the best ways to do this is by
storing multiple copies of your model,

673
00:45:23,939 --> 00:45:29,295
just transformed frame by frame, and then
loading them in every frame.

674
00:45:29,553 --> 00:45:34,576
Remember that the DMA is relatively fast,
so you can do this in realtime.

675
00:45:35,145 --> 00:45:40,937
You can also take a hybrid approach,
saving memory in your ROM by cutting

676
00:45:40,962 --> 00:45:46,731
the in between frames and linearly
interpolating on the CPU. This will

677
00:45:46,756 --> 00:45:52,330
obviously be very heavy as the
number of vertices increases,

678
00:45:52,355 --> 00:45:57,656
so at that point you might as well
implement a full, proper skeleton system.

679
00:45:58,184 --> 00:46:02,800
There's no microcode for skinned models
unfortunately, but it is theoretically

680
00:46:02,825 --> 00:46:07,967
possible, and would be a much smarter
solution than doing it purely on the CPU.

681
00:46:08,412 --> 00:46:16,619
A relatively cool trick for skinned meshes
is the fact that when you load vertices

682
00:46:16,649 --> 00:46:23,810
into the vertex cache, they're transformed
by the current matrix that's in the stack.

683
00:46:23,835 --> 00:46:27,374
This means that if you're careful with
how you load your vertices, you can

684
00:46:27,399 --> 00:46:32,369
effectively fake skinned meshes.
The idea is that you load

685
00:46:32,394 --> 00:46:38,679
one bone's worth of vertices, probably
want to ensure that you load the vertices

686
00:46:38,704 --> 00:46:48,227
that's at the tail of the bone last,
then you push the matrix for the next bone,

687
00:46:48,677 --> 00:46:51,538
and you load its corresponding vertices.

688
00:46:52,119 --> 00:46:56,072
You want to load those vertices at an
offset so that you don't overwrite

689
00:46:56,097 --> 00:47:02,611
the previous ones. So the new vertices will
be transformed but the old ones won't be.

690
00:47:03,223 --> 00:47:08,507
And then, you simply just need to
render an extra triangle in between these,

691
00:47:08,532 --> 00:47:14,152
in the connecting vertices, and here you
go, here's a fake skinned thing.

692
00:47:15,689 --> 00:47:21,933
There aren't any tools that let you do
this automatically, I did this by hand.

693
00:47:22,472 --> 00:47:28,801
And this method won't really work well
for meshes that have UV coordinates, since

694
00:47:28,826 --> 00:47:33,617
getting the textures to work right on
this is gonna be a little tricky.

695
00:47:34,382 --> 00:47:38,797
The other caveat is that obviously this
system only supports skinned models

696
00:47:38,822 --> 00:47:44,061
with vertices of weight 1 or 0, you won't
be able to have any in between weights.

697
00:47:44,682 --> 00:47:45,586
[Buu342]
Question?

698
00:47:45,611 --> 00:47:47,225
[psenough]
Question from the audience.

699
00:47:47,431 --> 00:47:48,106
[Buu342]
Yes?

700
00:47:49,005 --> 00:47:52,646
[psenough]
What was the main reason for

701
00:47:52,671 --> 00:47:56,991
making the models as sausage links? Is
there an aesthetic reason behind it?

702
00:47:57,016 --> 00:48:02,809
It's how I explained, it's because you
can just load in a chunk of the model

703
00:48:02,834 --> 00:48:12,433
and have the RSP do all the
vertex transformations, freeing up

704
00:48:12,458 --> 00:48:18,791
the CPU to do other stuff. It was just
much easier for the CPU since everything's

705
00:48:18,816 --> 00:48:24,139
being done by the RSP. The RSP is a
vector processor, it's fast, it can do it.

706
00:48:24,763 --> 00:48:27,915
So, audio development...
Audio development largely

707
00:48:27,940 --> 00:48:31,426
depends on the kind of microcode
that you're using, because the N64

708
00:48:31,451 --> 00:48:35,702
doesn't really have a dedicated audio
chip, it's done in the RSP.

709
00:48:36,278 --> 00:48:41,042
It's not locked to specific waveforms,
like the NES was, instead you just have

710
00:48:41,067 --> 00:48:46,410
a 16-Bit audio buffer somewhere in
RAM that you can just, with the

711
00:48:46,435 --> 00:48:50,430
combined effort of the CPU and RSP,
you just write waveform data into.

712
00:48:50,455 --> 00:48:53,782
Or you can just write it directly with
the CPU, if you really want to.

713
00:48:54,077 --> 00:49:00,780
Because the PAL and NTSC N64s run at
different clock rates, the audio will sound

714
00:49:00,805 --> 00:49:04,843
a little bit different between the
two regions, so you will need to

715
00:49:04,868 --> 00:49:10,521
adjust the audio between those two regions.

716
00:49:11,186 --> 00:49:13,731
It's important that you test on both
systems.

717
00:49:14,432 --> 00:49:19,199
It's also important that you give your
audio thread as much priority as possible,

718
00:49:19,224 --> 00:49:23,598
otherwise you will get pops or clicks.
And audio pops and clicks are much more

719
00:49:23,623 --> 00:49:27,602
noticeable than a dropped frame or
two. And much more annoying...

720
00:49:27,744 --> 00:49:30,968
So it helps to write a scheduler that
lets you interleave audio and

721
00:49:30,993 --> 00:49:32,752
graphics tasks properly.

722
00:49:33,206 --> 00:49:36,081
Thankfully a lot of the hard audio work
has been done for you, so instead

723
00:49:36,106 --> 00:49:40,109
you can just use one of the provided
libraries from your SDK of choice.

724
00:49:40,134 --> 00:49:44,859
For libultra, you have the naudio
microcode, which was used by both

725
00:49:44,884 --> 00:49:51,662
the Silicon Graphics' machine audio tools,
and the SoundTools on the PC.

726
00:49:51,789 --> 00:49:58,011
The RSP is used essentially to
decompress the audio, apply effects,

727
00:49:58,036 --> 00:50:03,501
generate music notes using MIDI from
sound banks that you can provide to it.

728
00:50:03,823 --> 00:50:07,443
The MIDI's themselves don't really have
any channel limits, because in the end

729
00:50:07,468 --> 00:50:11,746
everything just gets crushed into one
buffer, so that information will be

730
00:50:11,771 --> 00:50:12,606
lost anyway...

731
00:50:12,915 --> 00:50:17,781
libdragon recently got a new audio
microcode called RSP Mixer.

732
00:50:17,806 --> 00:50:23,432
I believe that's the name that they
use for it. There's no fancy name for it.

733
00:50:25,049 --> 00:50:28,676
Unlike the Nintendo microcode,
it's designed for XM modules and

734
00:50:28,701 --> 00:50:33,044
mostly for uncompressed audio
samples like WAV files.

735
00:50:33,536 --> 00:50:36,883
If you really don't care about
your ROM size, you can just store

736
00:50:36,908 --> 00:50:40,824
and stream your audio uncompressed,
directly from the cartridge.

737
00:50:41,864 --> 00:50:45,711
One highly popular method for
compressing is to store your sounds

738
00:50:45,736 --> 00:50:50,041
sped up, and then slowing them down
in the RSP. Because, y'know, sped up

739
00:50:50,066 --> 00:50:53,958
sounds are shorter, so obviously the
file size is going to be smaller.

740
00:50:54,184 --> 00:51:01,774
Obviously, the faster you make the
sound, the worse it will sound stretched.

741
00:51:04,655 --> 00:51:08,411
So, people have talked about
about MP3 playback. It's entirely

742
00:51:08,436 --> 00:51:16,676
possible, I know that Conker's
Bad Fur Day uses MP3 for its

743
00:51:16,701 --> 00:51:21,678
audio. When you start up the game,
it has like the little library copyright

744
00:51:21,703 --> 00:51:27,395
stuff on it. MP3 is a bit heavier on
the CPU than something like MP2,

745
00:51:27,420 --> 00:51:31,493
but there aren't really any public
microcode for either format, so you

746
00:51:31,518 --> 00:51:33,952
have to make do, unfortunately.

747
00:51:34,355 --> 00:51:36,149
[Audience Member]
Perfect Dark also uses MP3.

748
00:51:36,555 --> 00:51:39,173
[Buu342]
Possibly yes, since it's also Rare.

749
00:51:39,198 --> 00:51:41,199
They were by the same company.

750
00:51:41,455 --> 00:51:44,791
So, putting all that information together,
you've coded your game and you've

751
00:51:44,816 --> 00:51:46,246
made a terrible discovery!

752
00:51:46,277 --> 00:51:48,259
It runs like absolute ass!

753
00:51:48,584 --> 00:51:50,868
Yep! That's right, get used to it!

754
00:51:51,240 --> 00:51:55,455
F-Zero X is the only commercial game on
the system that I know of that runs

755
00:51:55,480 --> 00:51:58,542
at a near stable 60 frames per
second at all times.

756
00:51:59,230 --> 00:52:03,870
I've mentioned it before, but most games
on the system are fillrate limited, so

757
00:52:03,895 --> 00:52:08,435
you can use the CPU as much as
you want. To, y'know, help reduce

758
00:52:08,460 --> 00:52:11,263
overdraw, you can clip out triangles.

759
00:52:11,876 --> 00:52:15,781
Help out the RDP however you can.

760
00:52:16,518 --> 00:52:21,444
I've also heard about people talking
about overclocking the CPU, but don't

761
00:52:21,469 --> 00:52:27,628
do this, it's really stupid. There's no
benefit in doing so because 90% of

762
00:52:27,653 --> 00:52:32,043
the games out there won't benefit
from it. It'll potentially even mess up

763
00:52:32,068 --> 00:52:36,405
the timings, since games are designed
with the very specific timings of the

764
00:52:36,430 --> 00:52:42,803
CPU, and it can even break the VI
or other things.

765
00:52:43,733 --> 00:52:47,300
And obviously, it'll make the CPU run
hotter, which isn't a great idea because

766
00:52:47,325 --> 00:52:49,812
the console is completely passively cooled.

767
00:52:50,132 --> 00:52:54,607
One of the best ways to improve your
performance is to reduce texture loading.

768
00:52:55,173 --> 00:53:00,775
There's someone who made Mario Kart 64
run 40% percent times faster by simply

769
00:53:00,800 --> 00:53:06,339
just reducing texture loads. And by that,
I mean you load in the texture, and you

770
00:53:06,364 --> 00:53:10,926
render everything that uses that
specific texture. And you won't

771
00:53:10,951 --> 00:53:14,191
ever need to load it again. The text
that you're seeing here for this

772
00:53:14,223 --> 00:53:24,569
presentation, I essentially have a big list
of all the different characters in memory,

773
00:53:24,594 --> 00:53:29,118
split into chunks that will fit into
texture memory, and I do some

774
00:53:29,143 --> 00:53:35,231
processing on the CPU. I create a
hash table, where I put in all the

775
00:53:35,256 --> 00:53:39,096
specific letters that use a specific
texture, and like that I can just

776
00:53:39,121 --> 00:53:43,879
render all of the letters at once
that use that specific texture.

777
00:53:43,904 --> 00:53:47,783
You want to do this sort of stuff
as much as possible.

778
00:53:48,782 --> 00:53:54,240
You'll also want to optimize your
drawing order. So, you'll want to draw

779
00:53:54,265 --> 00:53:58,380
from front to back, because the
pixels that are drawn from behind

780
00:53:58,405 --> 00:54:01,052
a triangle can be skipped early.

781
00:54:01,851 --> 00:54:08,106
Also, an interesting tidbit, the Z-Buffer
is atrocious atrociously slow, but

782
00:54:08,131 --> 00:54:12,219
not everything that you draw
requires it, so you can selectively

783
00:54:12,244 --> 00:54:14,770
disable the Z-Buffer to
maximize your performance.

784
00:54:14,892 --> 00:54:18,831
If you really want, you can even
toggle anti-aliasing between frames.

785
00:54:18,856 --> 00:54:22,294
As in, like, render one frame with
anti-aliasing, render another frame

786
00:54:22,319 --> 00:54:25,119
without it, and have it swap
between the two.

787
00:54:25,552 --> 00:54:29,972
And the more obvious things, you can
use culling algorithms like

788
00:54:29,997 --> 00:54:33,562
Binary Space Partitioning, or use
Level of Detail models.

789
00:54:33,919 --> 00:54:39,333
I've mentioned it plenty before, but the
CPU bus is 32-Bits wide, so if

790
00:54:39,366 --> 00:54:42,462
you have your data aligned to
prevent cache misses, that's a

791
00:54:42,487 --> 00:54:47,240
great idea, and keep them in different
banks, that also helps.

792
00:54:47,874 --> 00:54:52,076
And I know that using compiler
optimization sounds a bit obvious,

793
00:54:52,101 --> 00:54:57,295
but Super Mario 64 shipped in debug
mode, and the performance is pretty

794
00:54:57,320 --> 00:55:00,421
noticeable, especially in the CPU
bottlenecked areas.

795
00:55:01,115 --> 00:55:01,648
Also,

796
00:55:01,673 --> 00:55:02,948
read the manual.

797
00:55:02,972 --> 00:55:04,936
Like, really do it.

798
00:55:05,166 --> 00:55:09,289
Yeah, I know it's like 30 chapters
long, and its very dry, but there's

799
00:55:09,314 --> 00:55:10,900
so much important stuff in it.

800
00:55:10,924 --> 00:55:11,713
[psenough]
Didn't you say that there was

801
00:55:11,738 --> 00:55:12,726
no documentation?

802
00:55:12,751 --> 00:55:14,716
[Buu342]
Oh, that's for the RSP.

803
00:55:14,741 --> 00:55:20,505
Yeah, for the RSP and the RDP, how
those things work internally, there's

804
00:55:20,530 --> 00:55:23,985
no documentation for that, but
you do have like a big thick manual of

805
00:55:24,010 --> 00:55:26,859
how to get stuff working, obviously,
otherwise you'd be screwed...

806
00:55:27,993 --> 00:55:31,848
Okay so, to wrap up this presentation, I
want to talk a little bit about the

807
00:55:31,873 --> 00:55:36,142
beginning, and the future of
Nintendo 64 homebrew development.

808
00:55:36,339 --> 00:55:40,864
So if anyone follows Nintendo gaming
news, you might be aware that Nintendo

809
00:55:40,889 --> 00:55:45,832
has a notoriously crappy attitude
for fan games. They've shut down

810
00:55:45,857 --> 00:55:50,408
lots of projects that have a lot of
really hard work put into them...

811
00:55:51,385 --> 00:55:53,981
I'd like to put your worries to rest
by mentioning the fact that Nintendo

812
00:55:54,006 --> 00:55:58,638
historically has never gone after homebrew
games. It only acts on fan games,

813
00:55:58,663 --> 00:56:01,866
because people are using their IP's and
characters without their permission.

814
00:56:02,129 --> 00:56:06,015
Like I mentioned, the Super Mario 64
decompilation project, it's still up after

815
00:56:06,040 --> 00:56:11,499
three years, because it contains no
game assets in its repository. You

816
00:56:11,524 --> 00:56:14,415
need a copy of the game, and you
run it through some scripts, and it

817
00:56:14,440 --> 00:56:16,575
will generate those assets for you.

818
00:56:20,179 --> 00:56:25,016
Originally, in 1997 a man by- er, I
think it's a man...

819
00:56:25,041 --> 00:56:28,089
SOMEONE by the name of ACTRAiSER
registers a little website

820
00:56:28,114 --> 00:56:31,866
called https://dextrose.com to collect
information about backup devices for

821
00:56:31,891 --> 00:56:36,288
the Nintendo 64. It quickly became a place
where people gathered to discuss and

822
00:56:36,313 --> 00:56:40,203
develop Nintendo 64 homebrew.
Unfortunately though, most of this

823
00:56:40,228 --> 00:56:43,261
website has been lost to time, but
it can still be partially surfed

824
00:56:43,286 --> 00:56:47,612
through the web archive. However,
in 1998, Dextrose, in collaboration

825
00:56:47,637 --> 00:56:52,324
with Bung Enterprises, the guys who
made that Dr. V64 that I mentioned before.

826
00:56:52,634 --> 00:56:57,885
They announced something called:
Presence of Mind. It was the first

827
00:56:57,910 --> 00:57:02,361
Nintendo 64 demo competition.
And the winners could take in some

828
00:57:02,386 --> 00:57:06,916
cool sponsored hardware by Bung, and
every competitor even got a free T-shirt.

829
00:57:06,941 --> 00:57:11,206
There's a demo for Presence of Mind
that's literally just called

830
00:57:11,231 --> 00:57:12,532
The T-shirt demo.

831
00:57:13,135 --> 00:57:16,666
The demo essentially says "we couldn't
make anything in time, but we heard

832
00:57:16,691 --> 00:57:18,814
we'd get a free T-shirt, so here's
something".

833
00:57:22,106 --> 00:57:25,685
There was a second and final
Presence of Mind in 1998.

834
00:57:25,854 --> 00:57:30,138
During this time frame, the system was
pretty hot, so we saw a lot of releases,

835
00:57:30,163 --> 00:57:33,248
a lot of demos, intros, and homebrew,
which is pretty cool.

836
00:57:34,024 --> 00:57:40,377
In 1999, an SGI employee leaks internal
documents containing Verilog code and

837
00:57:40,402 --> 00:57:45,083
a lot of really juicy details called:
The Oman Archives.

838
00:57:45,886 --> 00:57:47,001
[Audience Member]
The Oman Archives?

839
00:57:47,085 --> 00:57:49,655
[Buu342]
T̷̨̝̤̦͎͂̈́̅̎̈́ḩ̴͉̻͈̦͈͖̱̩̯͖̥͉̖́̈́̋̌͑͐͆̏̌̈͛̀͋͝é̴̺̝̗̰͖̗̪̹̦̳͎̹̾̆̂̉̈́̉͊̚͠ ̷̣̱̍͑̋̑̐͗̀̅̀̚͝͝O̷̞̳̘͖͓̗̫̦͈̅͠m̵̺͙̞̍̍̄̏̈̅̔̋̈͌͌͝ă̴̦̦͎̖̰͓͇̠̫̮̑̇̑͗̒̓͌̀̈̈́͘n̵̡̛͚̱̫͖͚̮̱̈́̒̉̏͒͝͝͝ͅ ̸̛̩͖̳̩̉̄̈́̓̌̓́͋̌͆͝͝͝Ä̶̧͇̘͉̫̗̲̘͙͚̺͜ͅͅŗ̴̬̗̻̘͕̳̟̳͍̻͖̤̾̿̒̾̋͜͜c̵̳͈͕͙̠̹̑̂̂͋̀̅̀͆͝h̸̢̛̼̻̑̍̌̎̿̚i̴̡̤͕̠̹͚̥̯̎͆̓̈́̑̔̿̋̉̂͜v̷̧͚͕̩̮̭̰͓̬̥̞͈̅̇̏͘͝ȩ̴̨̢̺͚̦̝͔͇͈͔̍̀̿̉̕͠͝s̸̰̖̯̣̲̥͈̻̭͈̹͚̠̆͌̆̕

840
00:57:49,680 --> 00:57:54,510
This has unfortunately tainted the N64
scene, and it has never been the same

841
00:57:54,535 --> 00:58:01,360
since. It's forbidden knowledge, and some
emulator developers have used them.

842
00:58:01,385 --> 00:58:02,558
They shouldn't have...

843
00:58:02,559 --> 00:58:06,791
And a lot of that information has
unfortunately propagated through

844
00:58:06,816 --> 00:58:08,810
the rest of the scene since.

845
00:58:09,653 --> 00:58:14,948
Eventually though, Project64 is released
in 2001 and it rises above the rest as

846
00:58:14,973 --> 00:58:17,745
one of the best Nintendo 64
emulators at the time.

847
00:58:17,999 --> 00:58:21,599
Eventually though, it's time for the
new console generation, so the Nintendo 64

848
00:58:21,624 --> 00:58:27,019
is discontinued in 2002, and at this point,
the interest in the system starts to

849
00:58:27,044 --> 00:58:32,712
and it's really only kept alive by a
small handful of users, mostly who

850
00:58:32,737 --> 00:58:37,402
are either emulator developers, hackers who
are working to translate the Japanese only

851
00:58:37,427 --> 00:58:42,422
games to English, or just people interested
in taking the system apart and figuring

852
00:58:42,447 --> 00:58:43,306
it out bit by bit.

853
00:58:44,750 --> 00:58:48,719
The emulation scene unfortunately
also saw quite a bit of infighting and

854
00:58:48,744 --> 00:58:53,104
elitism, which kind of still lingers to
this day. It's a bit unfortunate...

855
00:58:53,129 --> 00:58:55,259
[Audience Member]
What kind of fighting?

856
00:58:56,962 --> 00:58:59,567
[Buu342]
I really don't want to get into the drama.

857
00:58:59,592 --> 00:59:03,732
You can you can probably just search
Project64 on Wikipedia and there's a

858
00:59:03,764 --> 00:59:09,243
section called "controversy". Y'know,
it's always a good Wikipedia article

859
00:59:09,268 --> 00:59:12,087
when it has that section in it.

860
00:59:12,111 --> 00:59:13,579
[Audience Member]
What about high level emulation?

861
00:59:13,603 --> 00:59:14,643
Did that die off?

862
00:59:14,668 --> 00:59:17,507
[Buu342]
So, there was a high level emulator soon

863
00:59:17,532 --> 00:59:20,821
after The Oman Archives which had to be
discontinued because-

864
00:59:20,846 --> 00:59:22,240
[Audience Member]
UltraHLE?

865
00:59:22,669 --> 00:59:24,063
Was it UltraHLE?

866
00:59:24,088 --> 00:59:26,465
[Buu342]
Yes, UltraHLE! I don't know if that was

867
00:59:26,490 --> 00:59:32,110
the one that used part of the Oman
documentation, I'm a little bit hazy

868
00:59:32,154 --> 00:59:34,033
in that history, unfortunately...

869
00:59:34,057 --> 00:59:35,379
[Audience Member]
I remember that when it was released

870
00:59:35,403 --> 00:59:36,138
it was quite good.

871
00:59:36,163 --> 00:59:39,240
[Buu342]
Yes! It was very, very good for its time.

872
00:59:40,739 --> 00:59:45,176
So now we're seeing a bit of a renaissance.
Collectors have gotten ahold of the

873
00:59:45,201 --> 00:59:54,805
original development hardware and
disks. We saw the release of alt-libn64

874
00:59:54,830 --> 01:00:01,424
in 2008, which eventually merged with
libdragon in 2010. There was a lot of

875
01:00:01,449 --> 01:00:06,945
collaborative work from users to write
these free and open source libraries.

876
01:00:08,133 --> 01:00:14,533
And, of note, in 2011 marshallh, who made
my little cartridge, he released the

877
01:00:14,558 --> 01:00:19,772
MGC Demo, which was the first N64
demo in a long time. They also

878
01:00:19,797 --> 01:00:24,743
managed to fully reverse engineer the
CIC, which was the lockout chip on the

879
01:00:24,768 --> 01:00:29,797
system, and that eventually brought
the release of the 64Drive. It has

880
01:00:29,822 --> 01:00:35,648
something called the UltraCIC, which is
an open source CIC re-implementation

881
01:00:35,673 --> 01:00:43,985
that works on all sorts of CIC's. There's a
bunch of different CIC's and the UltraCIC

882
01:00:44,010 --> 01:00:45,403
supports all of them.

883
01:00:46,177 --> 01:00:51,678
Six years later, Discord happens,
and the N64brew Discord channel

884
01:00:51,703 --> 01:00:55,192
is created, which I end up joining and
releasing my first homebrew project

885
01:00:55,217 --> 01:00:56,521
in 2018.

886
01:00:56,910 --> 01:00:59,987
I know it feels a little bit cheeky
putting one of my own projects in

887
01:01:00,012 --> 01:01:09,185
a timeline of big occurrences, but before
my game, there wasn't really any properly

888
01:01:09,210 --> 01:01:13,818
documented N64 game. No one
had really gone into such an extent

889
01:01:13,843 --> 01:01:18,811
to make write-ups about how to make a
game, step by step. And that was one of

890
01:01:18,836 --> 01:01:20,988
the things that I did with my project.

891
01:01:21,365 --> 01:01:25,242
I promise one day I will finish that
documentation. I know I'm like 2 years

892
01:01:25,267 --> 01:01:25,760
behind, but-

893
01:01:25,785 --> 01:01:26,476
[Audience Member]
Is that online yet?

894
01:01:26,501 --> 01:01:28,273
[Buu342]
Yes it's online, obviously.

895
01:01:28,297 --> 01:01:29,637
[psenough]
Just unfinished, right?

896
01:01:29,662 --> 01:01:31,145
[Buu342]
It's just unfinished, but yes,

897
01:01:31,170 --> 01:01:38,634
If you search up Pyoro64, which is the
name of the project, you will find

898
01:01:38,659 --> 01:01:41,111
those Google Docs.

899
01:01:43,371 --> 01:01:45,056
Also worth noting-

900
01:01:45,080 --> 01:01:50,133
Oh! Also, the Pyoro thing,
sometimes when I look at

901
01:01:50,158 --> 01:01:54,559
other people's open source project,
I sometimes find a little bit of

902
01:01:54,584 --> 01:01:58,173
Pyoro code in there, so it's a little
bit nice-

903
01:01:58,504 --> 01:02:01,188
[Audience Member]
You mean they're copy pasting you code?

904
01:02:01,594 --> 01:02:04,121
[Buu342]
It's like a line or 2, but I can see

905
01:02:04,146 --> 01:02:08,769
from the comments that it came from my
ROM, so you know, people have found

906
01:02:08,794 --> 01:02:11,352
those samples very useful.

907
01:02:11,377 --> 01:02:13,456
Which is pretty good!

908
01:02:15,305 --> 01:02:19,030
As I mentioned, Super Mario 64 was
decompiled in 2019... Well it was

909
01:02:19,055 --> 01:02:25,052
decompiled before but it went public in
2019, and this completely exploded the

910
01:02:25,077 --> 01:02:29,551
Super Mario hacks, and N64 hacks
scene in general.

911
01:02:30,589 --> 01:02:36,671
Last year, N64brew hosted the very
first Nintendo64 homebrew competition.

912
01:02:36,696 --> 01:02:43,164
We had a 1000 dollar prize pool, and that
competition happened 20 years after

913
01:02:43,189 --> 01:02:45,177
the last Presence of Mind.

914
01:02:46,088 --> 01:02:50,111
We also created the N64brew wiki,

915
01:02:50,136 --> 01:02:53,814
which now kind of serves as a hub
for accurate hardware and software-

916
01:02:53,839 --> 01:02:54,498
[Audience Member]
Is this recent?

917
01:02:54,523 --> 01:02:56,153
[Buu342]
documentation. Yes, it's very recent.

918
01:02:56,178 --> 01:03:00,548
A lot of the documentation that you
can find online is wrong, and we're trying

919
01:03:00,573 --> 01:03:01,376
to correct that.

920
01:03:01,401 --> 01:03:02,007
[Audience Member]
Like what?

921
01:03:02,195 --> 01:03:04,168
[Buu342]
Lots of like, really finicky details,

922
01:03:04,193 --> 01:03:09,045
because as I mentioned, we thought
the CPU could only address 250 megabytes,

923
01:03:09,070 --> 01:03:12,498
turns out it can potentially address
more than that. But no one bothers

924
01:03:12,523 --> 01:03:13,323
to update this stuff-

925
01:03:13,347 --> 01:03:14,269
[Audience Member]
So it's for people who are

926
01:03:14,294 --> 01:03:15,193
more into hardware?

927
01:03:15,218 --> 01:03:17,880
[Buu342]
Yes, it's more for emulator-

928
01:03:17,881 --> 01:03:21,072
There's a little bit of everything in
there. It's got stuff for emulator

929
01:03:21,097 --> 01:03:25,847
developers but it also has a few guides
that I'm also helping write about

930
01:03:25,872 --> 01:03:27,520
software development in general.

931
01:03:28,100 --> 01:03:31,580
And in case you're wondering, yes, we're
hosting another game jam right now!

932
01:03:31,605 --> 01:03:35,463
Although, it is unfortunately a little
bit late to sign up... And this year's

933
01:03:35,488 --> 01:03:39,189
prize pool is instead going to charity
since we we want to try something

934
01:03:39,214 --> 01:03:40,703
a little bit different.

935
01:03:41,652 --> 01:03:45,151
This chart isn't really super
comprehensive, but I've tried

936
01:03:45,176 --> 01:03:49,466
to the best of my ability to
ensure it's somewhat accurate.

937
01:03:49,599 --> 01:03:54,375
the numbers over here-
I programmed a laser pointer!

938
01:03:54,577 --> 01:03:57,416
Because I was expecting to have to show
this on the console.

939
01:03:57,595 --> 01:03:59,264
[psenough]
Question. Is there a specific place

940
01:03:59,289 --> 01:04:01,537
where you collect all the homebrew
releases?

941
01:04:03,063 --> 01:04:05,581
[Buu342]
No... We we might do that with

942
01:04:05,606 --> 01:04:11,762
the wiki. For now, we put up a GitHub
repository with all the game jam entries

943
01:04:11,787 --> 01:04:14,385
from last year, and we're going to do the
same thing again.

944
01:04:14,517 --> 01:04:17,880
There's a website called
https://n64squid.com, where

945
01:04:17,905 --> 01:04:21,203
someone publishes articles about
all sorts of n64 homebrew.

946
01:04:21,287 --> 01:04:24,294
There's a website called
http://nesworld.com, it also has a

947
01:04:24,319 --> 01:04:30,089
big compilation of homebrew ROMs so
that's probably worth looking at...

948
01:04:31,317 --> 01:04:37,755
So the numbers here in the Dextrose
years, are a little bit inflated,

949
01:04:37,780 --> 01:04:42,798
because I've also included intros
and demos.

950
01:04:43,536 --> 01:04:44,949
After dextrose-

951
01:04:45,340 --> 01:04:46,278
[Audience Member]
But it's still homebrew, right?

952
01:04:46,303 --> 01:04:48,381
[Buu342]
Yeah it's still homebrew, but most

953
01:04:48,406 --> 01:04:51,104
people, when they think about
homebrew, they want to see games.

954
01:04:52,594 --> 01:04:56,923
You had a lot of that in the
Dextrose years,

955
01:04:56,948 --> 01:04:59,027
and less as time went on...

956
01:05:01,184 --> 01:05:04,301
And I'm also not including hacks,
if we include hacks, this chart would

957
01:05:04,326 --> 01:05:06,006
be much, much bigger.

958
01:05:06,444 --> 01:05:10,049
We've had translation patches and
all sort of stuff throughout the years,

959
01:05:10,074 --> 01:05:14,365
and I didn't include these in the chart.
It's not a super accurate chart, but it's

960
01:05:14,390 --> 01:05:17,189
just to get a general idea...

961
01:05:18,284 --> 01:05:26,311
You can see here that in 2017 we saw a
small uptick of homebrew, probably

962
01:05:26,336 --> 01:05:31,811
because of N64brew, but things
started going a bit more public...

963
01:05:32,075 --> 01:05:36,628
And then you can see in 2020 it suddenly
jumped up again with the game jam.

964
01:05:37,138 --> 01:05:38,484
[psenough]
They were asking if it was because of

965
01:05:38,509 --> 01:05:42,326
the pandemic? Like, everybody indoors had
a lot more time to hack at the N64?

966
01:05:42,778 --> 01:05:46,498
It probably helped...
It definitely helped...

967
01:05:47,450 --> 01:05:54,422
Okay, speaking of communities, if you like
IRC, you have #n64dev which is @ EFnet.

968
01:05:54,447 --> 01:05:58,830
It's one of the oldest active communities,
it was around during the Dextrose days,

969
01:05:58,855 --> 01:06:01,359
and it contains most of the old timers,
it has really knowledgeable folk there.

970
01:06:05,801 --> 01:06:09,751
N64brew Discord is the kind of go-to place
for homebrew development specifically.

971
01:06:09,776 --> 01:06:14,393
You also have Discord 64, you have
iQueBrew which is specifically for the

972
01:06:14,418 --> 01:06:17,055
Chinese console of the Nintendo 64.

973
01:06:17,079 --> 01:06:18,809
<Aside>
They had a Chinese version, yes.

974
01:06:19,039 --> 01:06:20,951
[psenough]
What's the difference between the normal

975
01:06:20,976 --> 01:06:21,776
and the Chinese version?

976
01:06:21,801 --> 01:06:23,106
[Buu342]
I'm not sure because I-

977
01:06:23,131 --> 01:06:24,102
[psenough]
It's Chinese!

978
01:06:24,127 --> 01:06:25,665
[Buu342]
I don't own one...

979
01:06:25,690 --> 01:06:29,848
The idea was that, because gaming
is super restricted in China,

980
01:06:29,873 --> 01:06:34,194
Nintendo had to release it slightly
differently, not as a gaming console,

981
01:06:34,219 --> 01:06:37,655
but as an entertainment thing instead.

982
01:06:38,645 --> 01:06:43,201
Instead, it's called the iQue Player,
instead of the Nintendo64

983
01:06:44,414 --> 01:06:49,312
And you also have a bunch of hacking
communities for very specific titles,

984
01:06:49,337 --> 01:06:56,294
like Super Mario 64, Legend of Zelda,
Banjo, GoldenEye, etc...

985
01:06:56,493 --> 01:07:01,242
And while it's not super active, if you
like Reddit, you also have the

986
01:07:01,267 --> 01:07:03,549
r/n64homebrew subreddit.

987
01:07:04,360 --> 01:07:07,685
Okay, well, that's everything!
Thanks for putting up with me.

988
01:07:07,710 --> 01:07:13,257
If you ever need to get in touch,
I have a bunch of links up here, in

989
01:07:13,282 --> 01:07:17,580
the places I've listed:
My email, my GitHub (where I

990
01:07:17,605 --> 01:07:20,722
open source everything, including the
source code for this presentation,

991
01:07:20,747 --> 01:07:23,873
because it IS a Nintendo64 ROM).

992
01:07:24,167 --> 01:07:27,107
I have a YouTube channel, I sometimes
publish stuff there...

993
01:07:27,132 --> 01:07:28,759
Whenever I feel like it...

994
01:07:29,397 --> 01:07:32,918
And my Discord, if you ever
need to get in touch directly.

995
01:07:33,027 --> 01:07:35,580
I'd like to give special thanks to
a bunch of people:

996
01:07:35,605 --> 01:07:39,650
Rasky, Bigbass, Hazematman,
Meeq, and mikeryan, for

997
01:07:39,675 --> 01:07:43,502
proofreading, correcting me, answering
questions, being helpful with

998
01:07:43,527 --> 01:07:44,897
putting this presentation together.

999
01:07:45,075 --> 01:07:48,854
There are a bunch of names that have
kept the N64 community alive

1000
01:07:48,879 --> 01:07:53,473
throughout the years. I'd spend ages
mentioning every single one, so here's a

1001
01:07:53,498 --> 01:07:56,921
few up on the screen. Not comprehensive,
at all!

1002
01:07:57,628 --> 01:08:03,247
N64brew has been a fantastic place that
has kept me there for over three years.

1003
01:08:03,272 --> 01:08:07,239
I highly recommend it!
And super thank you for that!

1004
01:08:07,264 --> 01:08:13,139
And obviously, Inércia for inviting me
to do this talk (and giving me

1005
01:08:13,164 --> 01:08:16,639
free food because I was doing the
seminar, thanks a lot, yeah).

1006
01:08:18,268 --> 01:08:19,593
Do you have time for questions?

1007
01:08:19,618 --> 01:08:21,975
[psenough]
Yeah, I'm asking on the chat if they

1008
01:08:22,000 --> 01:08:27,026
have any. There was one asking if it's
a proper old-school platform, or is it

1009
01:08:27,051 --> 01:08:31,462
still like "my console is a bit
outdated" sort of thing.

1010
01:08:31,803 --> 01:08:33,179
[Buu342]
I'd like to point out that the

1011
01:08:33,204 --> 01:08:36,824
PlayStation 3, at this point, is
considered retro.

1012
01:08:39,158 --> 01:08:46,994
The PlayStation 3 is over 10 years old,
so these systems are starting to get

1013
01:08:47,019 --> 01:08:48,738
quite old.

1014
01:08:50,076 --> 01:08:52,806
Oh yeah!
Here's a bunch of sources that you might

1015
01:08:52,831 --> 01:08:55,729
find useful.
The manual, read it!

1016
01:08:57,439 --> 01:08:59,868
[psenough]
Is there any effort to crack the

1017
01:08:59,893 --> 01:09:01,459
big black box in the middle?

1018
01:09:04,128 --> 01:09:06,389
[Buu342]
Yes! In fact, it's already been decapped.

1019
01:09:08,712 --> 01:09:14,090
But it's super complicated, so we
don't have like any... Yeah...

1020
01:09:15,370 --> 01:09:16,769
Any other questions?

1021
01:09:19,403 --> 01:09:20,902
[psenough]
Not right now.

1022
01:09:20,927 --> 01:09:22,769
So, everybody please-

1023
01:09:22,794 --> 01:09:24,238
There's a question!

1024
01:09:25,124 --> 01:09:29,276
What's the best n64 demo to watch?

1025
01:09:29,301 --> 01:09:31,261
[Buu342]
Okay so, for demos, I highly

1026
01:09:31,293 --> 01:09:35,399
recommend the MGC 2011 demo by marshallh.

1027
01:09:36,598 --> 01:09:40,445
And another really, really cool one is
called Nacho 64.

1028
01:09:41,835 --> 01:09:46,470
It does some really cool stuff, it has
a mirror in it!

1029
01:09:48,198 --> 01:09:50,993
[psenough]
I wonder if that was on purpose blackpawn,

1030
01:09:51,018 --> 01:09:52,217
that you asked that question.

1031
01:09:52,242 --> 01:09:56,587
Because blackpawn is getting this sort
of nacho theme going at Inércia, so I

1032
01:09:56,612 --> 01:09:59,810
wonder if that was related.
Curious...

1033
01:09:59,829 --> 01:10:01,314
[Buu342]
Those two are really, really impressive

1034
01:10:01,339 --> 01:10:05,181
looking, so I highly recommend those.
There's probably a few others, but I'm

1035
01:10:05,206 --> 01:10:07,533
not remembering right now from the top
of my head.

1036
01:10:07,558 --> 01:10:10,520
I would demonstrate them, if we
were running this presentation on

1037
01:10:10,545 --> 01:10:11,815
my console...

1038
01:10:11,840 --> 01:10:14,560
[psenough]
We... Does anyone know a cheap,

1039
01:10:14,585 --> 01:10:19,756
but reliable RCA to HDMI connector? If
you have one, please donate one to Buu,

1040
01:10:19,781 --> 01:10:21,286
he desperately needs one.

1041
01:10:22,288 --> 01:10:25,397
[Buu342]
I wanted to get a RetroTINK, but it's

1042
01:10:25,422 --> 01:10:29,685
40 bucks shipping to Portugal, and then
its 23% tax as soon as it arrives.

1043
01:10:30,149 --> 01:10:32,366
It hurts the wallet...

1044
01:10:33,159 --> 01:10:34,642
[psenough]
We have one more question, which was

1045
01:10:34,667 --> 01:10:38,558
highlighted here. Why did you get into
doing games for the N64?

1046
01:10:38,583 --> 01:10:40,350
What made you so interested?

1047
01:10:40,927 --> 01:10:42,639
[Buu342]
I owned the console.

1048
01:10:42,671 --> 01:10:44,451
[psenough]
Was it yours, or was it your parents'?

1049
01:10:44,476 --> 01:10:46,603
Because you're too young to have an N64!

1050
01:10:47,228 --> 01:10:48,347
[Buu342]
Wow, rude!

1051
01:10:49,290 --> 01:10:53,438
It was my cousins, actually they then
passed it onto my brother and I.

1052
01:10:53,707 --> 01:10:57,691
And now it's in my hands, since I do
homebrew development on it.

1053
01:10:59,926 --> 01:11:01,179
[psenough]
I think that's it, we don't have anything

1054
01:11:01,204 --> 01:11:04,652
else. Thank you so much Buu, that
was very interesting. Thank you so much!

1055
01:11:04,677 --> 01:11:05,722
Big round of applause!

1056
01:11:10,480 --> 01:11:16,051
And... We'll now have a short break to
prepare the next compos, which should be

1057
01:11:16,076 --> 01:11:21,079
15 minutes or something like that...
So yeah, stay tuned, and

1058
01:11:21,103 --> 01:11:22,603
we'll be right back!

